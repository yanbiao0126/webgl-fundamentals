<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/fr/webgl-how-it-works.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Ce que WebGL fait vraiment">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_fr.jpg">

<meta property="og:title" content="WebGL Comment ça marche">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_fr.jpg">
<meta property="og:description" content="Ce que WebGL fait vraiment">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Comment ça marche">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html">
<meta name="twitter:description" content="Ce que WebGL fait vraiment">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_fr.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_fr.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html",
      "inLanguage":"fr",
      "name":"WebGL Comment ça marche",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Comment ça marche</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-how-it-works.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-how-it-works.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-how-it-works.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-how-it-works.html" selected>Français</a>
    <option value="/webgl/lessons/ja/webgl-how-it-works.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-how-it-works.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-how-it-works.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-how-it-works.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-how-it-works.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-how-it-works.html" >简体中文</a>
</select>


    <a href="#toc">Table des Matières</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/fr/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Comment ça marche</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Cet article est la suite de <a href="webgl-fundamentals.html">WebGL - les bases</a>.
Avant de poursuivre je pense qu&#39;il faut discuter de ce que WebGL et la carte graphique
font vraiment. Il y a en gros 2 parties dans le travail de la carte graphique.
La première partie traite les vertices (du moins leurs données) et les convertit
en vertices dans l&#39;espace de coordonnées. La deuxième partie colore les pixels d&#39;après
la première partie.</p>
<p>Quand vous appelez</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.drawArrays(gl.TRIANGLES, 0, 9);
</code></pre><p>Le 9 ici signifie &quot;il y a 9 vertices à traiter&quot; donc voilà 9 vertices rendus.</p>
<p><img src="../resources/vertex-shader-anim.gif" class="webgl_center" /></p>
<p>Sur la gauche il y a les données fournies. Le shader de vertex est une fonction que vous écrivez en
<a href="webgl-shaders-and-glsl.html">GLSL</a>. Il est appelé une fois pour chaque vertex.
Vous écrivez quelques opérations et renseignez la variable <code class="notranslate" translate="no">gl_Position</code> avec une valeur
dans l&#39;espace de projection pour le vertex en cours. La carte graphique prend cette valeur et la met en mémoire.</p>
<p>En supposant que vous faîtes des <code class="notranslate" translate="no">TRIANGLES</code>, à chaque fois que cette première partie génère
3 points la carte graphique s&#39;en sert pour faire un triangle. Elle regarde quels pixels sont
concernés entre ces trois points, et pixélise le triangle. Pour chaque pixel elle va appeler
notre shader de fragment pour nous demander quelle couleur nous voulons pour ce pixel. Le
shader de fragment doit renseigner la variable <code class="notranslate" translate="no">gl_FragColor</code> avec la couleur finale de chaque pixel.</p>
<p>Tout ceci est passionnant mais comme vous voyez dans nos exemples jusqu&#39;à maintenant le
shader de fragment a très peu d&#39;information. Heureusement on peut lui en envoyer davantage. On
définit des “varyings” pour chaque valeur qu&#39;on veut transmettre du shader de vertex au shader
de fragment.</p>
<p>Un exemple simple est d&#39;envoyer les coordonnées en espace de projection directement du shader
de vertex au shader de fragment.</p>
<p>On va dessiner un simple triangle. Après notre <a href="webgl-2d-matrices.html">exemple précédent</a> changeons notre F en triangle.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Remplit le tampon avec les valeurs qui définissent un triangle
function creerGeometrie(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
             0, -100,
           150,  125,
          -175,  100]),
      gl.STATIC_DRAW);
}
</code></pre><p>Et on n&#39;a qu&#39;à rendre 3 points.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Rendu de la scène
function rendreLaScene() {
  ...
  // Rendu de la géométrie.
*  gl.drawArrays(gl.TRIANGLES, 0, 3);
}
</code></pre><p>Ensuite dans notre shader de vertex on déclare une <em>varying</em> pour passer des données au shader de fragment.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">varying vec4 v_couleur;
...
void main() {
  // Multiplie la position par la matrice
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);

  // Convertit de l&#39;espace de projection en espace de couleur :
  // L&#39;espace de projection va de -1.0 à +1.0
  // L&#39;espace de couleur va de 0.0 à 1.0
*  v_couleur = gl_Position * 0.5 + 0.5;
}
</code></pre><p>Et ensuite on déclare la même <em>varying</em> dans le shader de fragment.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

*varying vec4 v_couleur;

void main() {
*  gl_FragColor = v_couleur;
}
</code></pre><p>WebGL va faire le lien entre la varying du shader de vertex et celle qui a les mêmes type et nom dans le shader de fragment.</p>
<p>Voici la version fonctionnelle.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-triangle-with-position-for-color.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-triangle-with-position-for-color.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Bougez, tournez et changez l&#39;échelle du triangle. Puisque les couleurs sont calculées
depuis l&#39;espace de projection elles ne changent pas avec les transformations.
Elles sont relatives à l&#39;arrière-plan.</p>
<p>Maintenant réfléchissons. On ne calcule que 3 points. Notre shader de vertex
n&#39;est appelé que 3 fois et donc il ne calcule que 3 couleurs. Pourtant notre
triangle en a davantage. C&#39;est pour cela qu&#39;on appelle ces variables transmises entre shaders,
des <em>varying</em>.</p>
<p>WebGL prends les 3 valeurs qu&#39;on a calculées pour chaque point et
pixélise le triangle en interpolant entre les valeurs renseignées.
Pour chaque pixel le shader de fragment est appelé avec la valeur de
la varying interpolée pour ce pixel.</p>
<p>Dans l&#39;exemple précédent on a commencé avec 3 vertices.</p>
<p><style>
table.vertex_table {
  border: 1px solid black;
  border-collapse: collapse;
  font-family: monospace;
  font-size: small;
}</p>
<p>table.vertex_table th {
  background-color: #88ccff;
  padding-right: 1em;
  padding-left: 1em;
}</p>
<p>table.vertex_table td {
  border: 1px solid black;
  text-align: right;
  padding-right: 1em;
  padding-left: 1em;
}
</style></p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="2">Vertices</th></tr>
<tr><td>0</td><td>-100</td></tr>
<tr><td>150</td><td>125</td></tr>
<tr><td>-175</td><td>100</td></tr>
</table>
</div>

<p>Notre shader de vertex applique une matrice pour translater, tourner,
changer d&#39;échelle et convertir en espace de projection. Les valeurs
par défaut sont translation = 200, 150, rotation = 0, échelle = 1,1
donc on a en fait seulement une translation. Puisque la taille de notre
tampon est de 400x300 (taille du canvas) notre shader de vertex applique
la matrice et ensuite calcule les 3 vertices suivants dans l&#39;espace de projection.</p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">Valeurs renseignées à gl_Position</th></tr>
<tr><td>0.000</td><td>0.660</td></tr>
<tr><td>0.750</td><td>-0.830</td></tr>
<tr><td>-0.875</td><td>-0.660</td></tr>
</table>
</div>

<p>Il convertit aussi celle dans l&#39;espace de couleur et les renseigne dans les <em>varying</em>
v_couleur qu&#39;on a déclarées.</p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">Valeurs renseignées à v_couleur</th></tr>
<tr><td>0.5000</td><td>0.830</td><td>0.5</td></tr>
<tr><td>0.8750</td><td>0.086</td><td>0.5</td></tr>
<tr><td>0.0625</td><td>0.170</td><td>0.5</td></tr>
</table>
</div>

<p>Ces 3 valeurs écrites dans v_couleur sont ensuite interpolées et passées au
shader de fragment pour chaque pixel.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 600px; height: 400px;" src="/webgl/lessons/resources/fragment-shader-anim.html"></iframe>
  <div class="webgl_center">v_couleur est interpolé entre v0, v1 et v2</div>
</div>

</p>
<p>On peut aussi envoyer plus de données au shader de vertex et les
transmettre ensuite au shader de fragment. Par exemple, dessinons un rectangle,
soit 2 triangles, en 2 couleurs. Pour cela on va indiquer un autre attribut
dans le shader de vertex pour lui envoyer cette nouvelle information, et on va la
transmettre directement au shader de fragment.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec2 a_position;
+attribute vec4 a_couleur;
...
varying vec4 v_couleur;

void main() {
   ...
  // Copie la couleur de l&#39;attribut à la varying.
*  v_couleur = a_couleur;
}
</code></pre><p>Maintenant il nous faut indiquer les couleurs dans nos géométries.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // créé les pointeurs pour nos données de vertices
  var emplacementPosition = gl.getAttribLocation(program, &quot;a_position&quot;);
+  var emplacementCouleur = gl.getAttribLocation(program, &quot;a_couleur&quot;);
  ...
+  // Créé un tampon pour les couleurs
+  var tampon = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, tampon);
+  gl.enableVertexAttribArray(emplacementCouleur);
+  gl.vertexAttribPointer(emplacementCouleur, 4, gl.FLOAT, false, 0, 0);

  // Créé les valeurs des couleurs
+  creerCouleurs(gl);
  ...

+// Remplit le tampon avec les couleurs pour les deux triangles
+// qui forment le rectangle.
+function creerCouleurs(gl) {
+  // Créé deux couleurs au hasard
+  var r1 = Math.random();
+  var b1 = Math.random();
+  var g1 = Math.random();
+
+  var r2 = Math.random();
+  var b2 = Math.random();
+  var g2 = Math.random();
+
+  gl.bufferData(
+      gl.ARRAY_BUFFER,
+      new Float32Array(
+        [ r1, b1, g1, 1,
+          r1, b1, g1, 1,
+          r1, b1, g1, 1,
+          r2, b2, g2, 1,
+          r2, b2, g2, 1,
+          r2, b2, g2, 1]),
+      gl.STATIC_DRAW);
+}
</code></pre><p>Voici le résultat</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-2-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-2-colors.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Notons que nous avons deux couleurs homogènes dans les triangles. Pourtant on passe
bien les couleurs à nos <em>varying</em> et elles sont toujours interpolées pour chaque
pixel. Mais on a mis les mêmes couleurs aux sommets d&#39;un même
triangle, d&#39;où ce résultat. Si on indique des couleurs différentes l&#39;interpolation
redevient visible :</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Remplit le tampon avec les couleurs pour les deux triangles
// qui forment le rectangle.
function creerCouleurs(gl) {
  // Créé une couleur différente par vertex
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(
*        [ Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1]),
      gl.STATIC_DRAW);
}
</code></pre><p>L&#39;interpolation de nos <em>varying</em> est visible.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-random-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-random-colors.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>

</p>
<p>Rien de très excitant je suppose mais ça démontre l&#39;utilisation de
plusieurs attributs et la transmission d&#39;information entre les deux shaders.
Si vous jetez un oeil aux <a href="webgl-image-processing.html">exemples de traitement d&#39;image</a>
on verra qu&#39;ils utilisent aussi un attribut spécial pour transmettre les coordonnées de texture.</p>
<h2 id="que-font-ces-tampons-et-ces-fonctions-pour-attributs-">Que font ces tampons et ces fonctions pour attributs ?</h2>
<p>Les tampons (buffer) sont l&#39;espace mémoire dans la carte graphique dans lequel on place les informations
de géométrie. <code class="notranslate" translate="no">gl.createBuffer</code> créé un tampon.
<code class="notranslate" translate="no">gl.bindBuffer</code> active le tampon pour une action à suivre.
<code class="notranslate" translate="no">gl.bufferData</code> place des données dans le tampon.</p>
<p>Une fois que les données sont dans le tampon on doit indiquer au programme WebGL comment
lire ces données et où sont les attributs à envoyer à notre shader de vertex.</p>
<p>Pour cela on demande d&#39;abord au programme WebGL l&#39;emplacement qu&#39;il a assigné aux attributs (le pointeur).
Par exemple dans le code précédent on a</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// créé les pointeurs pour nos données de vertices
var emplacementPosition = gl.getAttribLocation(programme, &quot;a_position&quot;);
var emplacementCouleur = gl.getAttribLocation(programme, &quot;a_couleur&quot;);
</code></pre><p>Une fois qu&#39;on connaît l&#39;emplacement d&#39;un attribut on soumet deux commandes.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(emplacement);
</code></pre><p>Cette commande dit à WebGL qu&#39;on veut fournir des données depuis un tampon</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.vertexAttribPointer(
    emplacement,
    nombreDeComposantes,
    typeDeDonnée,
    donnéesNormaliséesOuNon,
    tailleDeLaFenêtreDeLecture,
    décalage);
</code></pre><p>Et cette commande dit à WebGL d&#39;utiliser les données du dernier tampon activé gl.bindBuffer,
combien de composants il y a dans l&#39;attribut par vertex (1 - 4), de quel type de données il s&#39;agit
(<code class="notranslate" translate="no">BYTE</code>, <code class="notranslate" translate="no">FLOAT</code>, <code class="notranslate" translate="no">INT</code>, <code class="notranslate" translate="no">UNSIGNED_SHORT</code>, etc.), la taille (en byte) de la fenêtre de lecture,
et le décalage de départ de la première composante de l&#39;attribut.</p>
<p>Le nombre de composantes est toujours compris entre 1 et 4.</p>
<p>Si vous utilisez un tampon par type de données alors la fenêtre de lecture et le décalage de départ
peuvent être laissés à 0. 0 pour la fenêtre de lecture signifie &quot;utilise une fenêtre qui correspond
au type et à la la taille des données indiquées&quot;. 0 pour le décalage signifie que le démarrage de
la lecture commence à la première donnée du tampon. Mais indiquer d&#39;autres valeurs devient plus compliqué et
bien que ça ait des avantages en performance, ça ne vaut pas toujours le coup à moins que vous poussiez les limites
de votre carte graphique.</p>
<p>J&#39;espère que ça éclaire les notions de tampon et d&#39;attribut.</p>
<p>Rendez-vous ensuite à <a href="webgl-shaders-and-glsl.html">shaders et GLSL</a>.</p>
<div class="webgl_bottombar"><h3>Qu'est-ce que le paramètre donnéesNormaliséesOuNon dans la métode vertexAttribPointer?</h3>
<p>
La normalisation concerne les valeurs à type non décimal (autre que FLOAT).
Si vous mettez false, ces valeurs seront interprétées avec le type qu'elles ont.
BYTE va de -128 à 127, UNSIGNED_BYTE va de 0 à 255, SHORT va de -32768 à 32767 etc...
</p>
<p>
Si vous mettez true alors les valeurs d'un BYTE (-128 à 127)
sont transformées en -1.0 à +1.0, UNSIGNED_BYTE (0 à 255) en 0.0 to +1.0.
Les valeurs de type SHORT vont aussi de -1.0 to +1.0 mais ont plus de précision que BYTE.
</p>
<p>
Le cas le plus courrant de données normalisées est pour les couleurs. La
plupart du temps les couleurs vont de 0.0 à 1.0. Utiliser un FLOAT complet pour chaque composante
rouge, verte, bleue et alpha demande 16 bytes par vertex et par couleur. Avec des grosses géométries
ça fait beaucoup de mémoire. En convertissant les couleurs en UNSIGNED_BYTE 0 vaudra 0.0 et 255 vaudra 1.0.
Et ça ne demandera que 4 bytes par couleur soit une économie de 75%.
</p>
<p>Changeons notre code pour faire ça. Quand on dit au programme WebGL de prendre nos couleurs on utilisera </p>
<pre class="prettyprint showlinemods">
  gl.vertexAttribPointer(emplacementCouleur, 4, gl.UNSIGNED_BYTE, true, 0, 0);
</pre>
<p>Et quand on remplit notre tampon avec les couleurs :</p>
<pre class="prettyprint showlinemods">
// Remplit le tampon avec les couleurs pour les deux triangles
// qui forment le rectangle.
function creerCouleurs(gl) {
  // Créé deux couleurs aléatoires
  var r1 = Math.random() * 256; // 0 à 255.99999
  var b1 = Math.random() * 256; // ces valeurs
  var g1 = Math.random() * 256; // seront tronquées
  var r2 = Math.random() * 256; // une fois placées dans un
  var b2 = Math.random() * 256; // Uint8Array
  var g2 = Math.random() * 256;

gl.bufferData(
gl.ARRAY_BUFFER,
new Uint8Array( // Uint8Array
[ r1, b1, g1, 255,
r1, b1, g1, 255,
r1, b1, g1, 255,
r2, b2, g2, 255,
r2, b2, g2, 255,
r2, b2, g2, 255]),
gl.STATIC_DRAW);
}

</pre>
<p>
Voilà le résultat
</p>

<div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-2-byte-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-2-byte-colors.html" target="_blank">Cliquer ici pour ouvrir dans une nouvelle fenêtre</a>
</div>



</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-how-it-works.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-how-it-works.html" selected>Français</a>
    <option value="/webgl/lessons/ja/webgl-how-it-works.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-how-it-works.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-how-it-works.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-how-it-works.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-how-it-works.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-how-it-works.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Les bases</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-fundamentals.html">WebGL - Les bases</a></li>
<li><a href="/webgl/lessons/fr/webgl-how-it-works.html">WebGL - Comment ça marche</a></li>
<li><a href="/webgl/lessons/fr/webgl-shaders-and-glsl.html">WebGL - Shaders et GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Traitement d'image</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/fr/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D : translation, rotation, échelle, matrices</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-2d-translation.html">WebGL 2D - Translation</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-rotation.html">WebGL 2D - Rotation</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-scale.html">WebGL 2D - Echelle</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-matrices.html">WebGL 2D - Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-orthographic.html">WebGL 3D - Projection orthographique</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-perspective.html">WebGL 3D - La perspective</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-camera.html">WebGL 3D - Les caméras</a></li>
        </ul>
  <li>Lumières</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-lighting-directional.html">WebGL 3D - Lumière directionnelle</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-lighting-point.html">WebGL 3D - Lumière-point</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure et Organisation</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/fr/webgl-drawing-multiple-things.html">Dessiner plusieurs choses</a></li>
<li><a href="/webgl/lessons/fr/webgl-scene-graph.html">WebGL - Graphes de scène</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/fr/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/fr/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/fr/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/fr/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/fr/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/fr/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/fr/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/fr/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/fr/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/fr/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/fr/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Texte</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/fr/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/fr/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/fr/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/fr/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/fr/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Divers</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/fr/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/fr/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/fr/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/fr/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/fr/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/fr/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/fr/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/fr/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/fr/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/fr/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/fr/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/fr/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/fr/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/fr/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/fr/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/fr/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/fr/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/fr/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/fr/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Aide pour la doc de l'API</a></li>
  <li><a href="https://twgljs.org">TWGL, une librairie de base pour WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Une question ? <a href="https://stackoverflow.com/questions/tagged/webgl">Demander sur stackoverflow</a>.</div>
        <div>Un problème ? <a href="https://github.com/vinci-mz/webgl-fundamentals/issues">Signaler sur github</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Comment ça marche';
            var disqus_title = 'WebGL Comment ça marche';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



