<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-shaders-and-glsl.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="着色器和GLSL分别是什么">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_zh-cn.jpg">

<meta property="og:title" content="WebGL 着色器和GLSL">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_zh-cn.jpg">
<meta property="og:description" content="着色器和GLSL分别是什么">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 着色器和GLSL">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">
<meta name="twitter:description" content="着色器和GLSL分别是什么">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_zh-cn.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_zh-cn.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html",
      "inLanguage":"zh-cn",
      "name":"WebGL 着色器和GLSL",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 着色器和GLSL</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shaders-and-glsl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-shaders-and-glsl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 着色器和GLSL</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>此文上接<a href="webgl-fundamentals.html">WebGL 基础概念</a>。
如果你还没有阅读WebGL工作原理，也许可以先<a href="webgl-how-it-works.html">阅读这篇文章</a>。</p>
<p>我们之前提到过着色器和GLSL，但是没有涉及细节，你可能已经对此有所了解，
但以防万一，这里将详细讲解着色器和GLSL。</p>
<p>在<a href="webgl-how-it-works.html">工作原理</a>中我们提到，WebGL每次绘制需要两个着色器，
一个<strong>顶点着色器</strong>和一个<strong>片段着色器</strong>，每一个着色器都是一个<strong>方法</strong>。
一个顶点着色器和一个片段着色器链接在一起放入一个着色程序中（或者只叫程序）。
一个典型的WebGL应用会有多个着色程序。</p>
<h2 id="-">顶点着色器</h2>
<p>一个顶点着色器的工作是生成裁剪空间坐标值，通常是以下的形式</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">void main() {
   gl_Position = doMathToMakeClipspaceCoordinates
}
</code></pre><p>每个顶点调用一次（顶点）着色器，每次调用都需要设置一个特殊的全局变量<code class="notranslate" translate="no">gl_Position</code>，
该变量的值就是裁减空间坐标值。</p>
<p>顶点着色器需要的数据，可以通过以下三种方式获得。</p>
<ol>
<li><a href="#attributes-">Attributes 属性</a> (从缓冲中获取的数据)</li>
<li><a href="#uniforms-">Uniforms 全局变量</a> (在一次绘制中对所有顶点保持一致值)</li>
<li><a href="#textures-">Textures 纹理</a> (从像素或纹理元素中获取的数据)</li>
</ol>
<h3 id="attributes-">Attributes 属性</h3>
<p>最常用的方法是缓冲和<strong>属性</strong>，在<a href="webgl-how-it-works.html">工作原理</a>
中讲到了缓冲和属性，你可以创建缓冲，</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var buf = gl.createBuffer();
</code></pre><p>将数据存入缓冲</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);
</code></pre><p>然后初始化的时候，在你制作的（着色）程序中找到属性所在地址</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionLoc = gl.getAttribLocation(someShaderProgram, &quot;a_position&quot;);
</code></pre><p>在渲染的时候告诉WebGL怎么从缓冲中获取数据传递给属性</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 开启从缓冲中获取数据
gl.enableVertexAttribArray(positionLoc);

var numComponents = 3;  // (x, y, z)
var type = gl.FLOAT;    // 32位浮点数据
var normalize = false;  // 不标准化
var offset = 0;         // 从缓冲起始位置开始获取
var stride = 0;         // 到下一个数据跳多少位内存
                        // 0 = 使用当前的单位个数和单位长度 （ 3 * Float32Array.BYTES_PER_ELEMENT ）

gl.vertexAttribPointer(positionLoc, numComponents, type, false, stride, offset);
</code></pre><p>在<a href="webgl-fundamentals.html">WebGL 基础概念</a>中示范了不做任何运算直接将数据传递给<code class="notranslate" translate="no">gl_Position</code>。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;

void main() {
   gl_Position = a_position;
}
</code></pre><p>如果缓冲中存的是裁剪空间坐标就没什么问题。</p>
<p>属性可以用 <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, <code class="notranslate" translate="no">vec4</code>, <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code> 和 <code class="notranslate" translate="no">mat4</code> 数据类型。</p>
<h3 id="uniforms-">Uniforms 全局变量</h3>
<p>全局变量在一次绘制过程中传递给着色器的值都一样，在下面的一个简单的例子中，
用全局变量给顶点着色器添加了一个偏移量</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
+uniform vec4 u_offset;

void main() {
   gl_Position = a_position + u_offset;
}
</code></pre><p>现在可以把所有顶点偏移一个固定值，首先在初始化时找到全局变量的地址</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var offsetLoc = gl.getUniformLocation(someProgram, &quot;u_offset&quot;);
</code></pre><p>然后在绘制前设置全局变量</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform4fv(offsetLoc, [1, 0, 0, 0]);  // 向右偏移一半屏幕宽度
</code></pre><p>要注意的是全局变量属于单个着色程序，如果多个着色程序有同名全局变量，需要找到每个全局变量并设置自己的值。
我们调用<code class="notranslate" translate="no">gl.uniform???</code>的时候只是设置了<strong>当前程序</strong>的全局变量，当前程序是传递给<code class="notranslate" translate="no">gl.useProgram</code>
的最后一个程序。</p>
<p>全局变量有很多类型，对应的类型有对应的设置方法。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1f (floatUniformLoc, v);                 // float
gl.uniform1fv(floatUniformLoc, [v]);               // float 或 float array
gl.uniform2f (vec2UniformLoc,  v0, v1);            // vec2
gl.uniform2fv(vec2UniformLoc,  [v0, v1]);          // vec2 或 vec2 array
gl.uniform3f (vec3UniformLoc,  v0, v1, v2);        // vec3
gl.uniform3fv(vec3UniformLoc,  [v0, v1, v2]);      // vec3 或 vec3 array
gl.uniform4f (vec4UniformLoc,  v0, v1, v2, v4);    // vec4
gl.uniform4fv(vec4UniformLoc,  [v0, v1, v2, v4]);  // vec4 或 vec4 array

gl.uniformMatrix2fv(mat2UniformLoc, false, [  4x element array ])  // mat2 或 mat2 array
gl.uniformMatrix3fv(mat3UniformLoc, false, [  9x element array ])  // mat3 或 mat3 array
gl.uniformMatrix4fv(mat4UniformLoc, false, [ 16x element array ])  // mat4 或 mat4 array

gl.uniform1i (intUniformLoc,   v);                 // int
gl.uniform1iv(intUniformLoc, [v]);                 // int 或 int array
gl.uniform2i (ivec2UniformLoc, v0, v1);            // ivec2
gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          // ivec2 或 ivec2 array
gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        // ivec3
gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      // ivec3 or ivec3 array
gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    // ivec4
gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  // ivec4 或 ivec4 array

gl.uniform1i (sampler2DUniformLoc,   v);           // sampler2D (textures)
gl.uniform1iv(sampler2DUniformLoc, [v]);           // sampler2D 或 sampler2D array

gl.uniform1i (samplerCubeUniformLoc,   v);         // samplerCube (textures)
gl.uniform1iv(samplerCubeUniformLoc, [v]);         // samplerCube 或 samplerCube array
</code></pre><p>还有一些类型 <code class="notranslate" translate="no">bool</code>, <code class="notranslate" translate="no">bvec2</code>, <code class="notranslate" translate="no">bvec3</code>, and <code class="notranslate" translate="no">bvec4</code>。它们可用<code class="notranslate" translate="no">gl.uniform?f?</code>或<code class="notranslate" translate="no">gl.uniform?i?</code>。</p>
<p>一个数组可以一次设置所有的全局变量，例如</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 着色器里
uniform vec2 u_someVec2[3];

// JavaScript 初始化时
var someVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2&quot;);

// 渲染的时候
gl.uniform2fv(someVec2Loc, [1, 2, 3, 4, 5, 6]);  // 设置数组 u_someVec2
</code></pre><p>如果你想单独设置数组中的某个值，就要单独找到该值的地址。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// JavaScript 初始化时
var someVec2Element0Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[0]&quot;);
var someVec2Element1Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[1]&quot;);
var someVec2Element2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[2]&quot;);

// 渲染的时候
gl.uniform2fv(someVec2Element0Loc, [1, 2]);  // set element 0
gl.uniform2fv(someVec2Element1Loc, [3, 4]);  // set element 1
gl.uniform2fv(someVec2Element2Loc, [5, 6]);  // set element 2
</code></pre><p>同样的，如果你创建了一个结构体</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">struct SomeStruct {
  bool active;
  vec2 someVec2;
};
uniform SomeStruct u_someThing;
</code></pre><p>你需要找到每个元素的地址</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someThingActiveLoc = gl.getUniformLocation(someProgram, &quot;u_someThing.active&quot;);
var someThingSomeVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someThing.someVec2&quot;);
</code></pre><h3 id="-">纹理（顶点着色器中）</h3>
<p>同 <a href="#textures-">Textures 纹理（在片段着色器中）</a>。</p>
<h2 id="-">片段着色器</h2>
<p>一个片段着色器的工作是为当前光栅化的像素提供颜色值，通常是以下的形式</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

void main() {
   gl_FragColor = doMathToMakeAColor;
}
</code></pre><p>每个像素都将调用一次片段着色器，每次调用需要从你设置的特殊全局变量<code class="notranslate" translate="no">gl_FragColor</code>中获取颜色信息。</p>
<p>片段着色器所需的数据，可以通过以下三种方式获取</p>
<ol>
<li><a href="#uniforms-">Uniforms 全局变量</a> (values that stay the same for every pixel of a single draw call)</li>
<li><a href="#textures-">Textures 纹理</a> (data from pixels/texels)</li>
<li><a href="#varyings-">Varyings 可变量</a> (data passed from the vertex shader and interpolated)</li>
</ol>
<h3 id="uniform-">Uniform 全局变量（片段着色器中）</h3>
<p>同 <a href="#uniforms-">Uniforms 全局变量</a>.</p>
<h3 id="textures-">Textures 纹理（片段着色器中）</h3>
<p>在着色器中获取纹理信息，可以先创建一个<code class="notranslate" translate="no">sampler2D</code>类型全局变量，然后用GLSL方法<code class="notranslate" translate="no">texture2D</code>
从纹理中提取信息。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

uniform sampler2D u_texture;

void main() {
   vec2 texcoord = vec2(0.5, 0.5);  // 获取纹理中心的值
   gl_FragColor = texture2D(u_texture, texcoord);
}
</code></pre><p>从纹理中获取的数据<a href="webgl-3d-textures.html">取决于很多设置</a>。
至少要创建并给纹理填充数据，例如</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
var level = 0;
var width = 2;
var height = 1;
var data = new Uint8Array([
   255, 0, 0, 255,   // 一个红色的像素
   0, 255, 0, 255,   // 一个绿色的像素
]);
gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
</code></pre><p>在初始化时找到全局变量的地址</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someSamplerLoc = gl.getUniformLocation(someProgram, &quot;u_texture&quot;);
</code></pre><p>在渲染的时候WebGL要求纹理必须绑定到一个纹理单元上</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var unit = 5;  // 挑选一个纹理单元
gl.activeTexture(gl.TEXTURE0 + unit);
gl.bindTexture(gl.TEXTURE_2D, tex);
</code></pre><p>然后告诉着色器你要使用的纹理在那个纹理单元</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1i(someSamplerLoc, unit);
</code></pre><h3 id="varyings-">Varyings 可变量</h3>
<p>在<a href="webgl-how-it-works.html">工作原理</a>提到过，可变量是一种顶点着色器给片段着色器传值的方式。</p>
<p>为了使用可变量，要在两个着色器中定义同名的可变量。
给顶点着色器中可变量设置的值，会作为参考值进行内插，在绘制像素时传给片段着色器的可变量。</p>
<p>顶点着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;

uniform vec4 u_offset;

+varying vec4 v_positionWithOffset;

void main() {
  gl_Position = a_position + u_offset;
+  v_positionWithOffset = a_position + u_offset;
}
</code></pre><p>片段着色器</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

+varying vec4 v_positionWithOffset;

void main() {
+  // 从裁剪空间 (-1 &lt;-&gt; +1) 转换到颜色空间 (0 -&gt; 1).
+  vec4 color = v_positionWithOffset * 0.5 + 0.5;
+  gl_FragColor = color;
}
</code></pre><p>上方的示例几乎没有意义，通常情况下直接将裁剪空间的值传给片段着色器当作颜色值是没有意义的，
虽然它可以运行并且可以生成颜色值。</p>
<h2 id="glsl">GLSL</h2>
<p>GLSL全称是 Graphics Library Shader Language （图形库着色器语言），是着色器使用的语言。
它有一些不同于JavaScript的特性，主要目的是为栅格化图形提供常用的计算功能。
所以它内建的数据类型例如<code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>和 <code class="notranslate" translate="no">vec4</code>分别代表两个值，三个值和四个值，
类似的还有<code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code> 和 <code class="notranslate" translate="no">mat4</code> 分别代表 2x2, 3x3 和 4x4 矩阵。
你可以做一些运算例如常量和矢量的乘法。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 a = vec4(1, 2, 3, 4);
vec4 b = a * 2.0;
// b 现在是 vec4(2, 4, 6, 8);
</code></pre><p>它同样可以做矩阵乘法以及矢量和矩阵的乘法</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">mat4 a = ???
mat4 b = ???
mat4 c = a * b;

vec4 v = ???
vec4 y = c * v;
</code></pre><p>他还为矢量数据提供多种分量选择器，例如 vec4</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 v;
</code></pre><ul>
<li><code class="notranslate" translate="no">v.x</code> 和 <code class="notranslate" translate="no">v.s</code> 以及 <code class="notranslate" translate="no">v.r</code> ， <code class="notranslate" translate="no">v[0]</code> 表达的是同一个分量。</li>
<li><code class="notranslate" translate="no">v.y</code> 和 <code class="notranslate" translate="no">v.t</code> 以及 <code class="notranslate" translate="no">v.g</code> ， <code class="notranslate" translate="no">v[1]</code> 表达的是同一个分量。</li>
<li><code class="notranslate" translate="no">v.z</code> 和 <code class="notranslate" translate="no">v.p</code> 以及 <code class="notranslate" translate="no">v.b</code> ， <code class="notranslate" translate="no">v[2]</code> 表达的是同一个分量。</li>
<li><code class="notranslate" translate="no">v.w</code> 和 <code class="notranslate" translate="no">v.q</code> 以及 <code class="notranslate" translate="no">v.a</code> ， <code class="notranslate" translate="no">v[3]</code> 表达的是同一个分量。</li>
</ul>
<p>它还支持矢量<strong>调制</strong>，意味者你可以交换或重复分量。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.yyyy
</code></pre><p>和</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.y, v.y, v.y, v.y)
</code></pre><p>是一样的</p>
<p>同样的</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.bgra
</code></pre><p>和</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.b, v.g, v.r, v.a)
</code></pre><p>等价</p>
<p>当构造一个矢量或矩阵时可以一次提供多个分量，例如</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.rgb, 1)
</code></pre><p>和</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.r, v.g, v.b, 1)
</code></pre><p>是一样的</p>
<p>同样</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(1)
</code></pre><p>和</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(1, 1, 1, 1)
</code></pre><p>相同</p>
<p>值得注意的是GLSL是一个强类型的语言。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1;  // 错误，1是int类型，不能将int型赋值给float
</code></pre><p>正确的方式是</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1.0;      // 使用float
float f = float(1)  // 转换integer为float
</code></pre><p>上例中 <code class="notranslate" translate="no">vec4(v.rgb, 1)</code> 不会因为 <code class="notranslate" translate="no">1</code> 报错，因为 <code class="notranslate" translate="no">vec4</code> 内部进行了转换类似 <code class="notranslate" translate="no">float(1)</code> 。</p>
<p>GLSL有一系列内置方法，其中大多数运算支持多种数据类型，并且一次可以运算多个分量，例如</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">T sin(T angle)
</code></pre><p>T可以是 <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code> 或 <code class="notranslate" translate="no">vec4</code> 。如果你传的是 <code class="notranslate" translate="no">vec4</code> 返回的也是 <code class="notranslate" translate="no">vec4</code>,
返回结果对应每个分量的正弦值。换句话说如果 <code class="notranslate" translate="no">v</code> 是 <code class="notranslate" translate="no">vec4</code> 类型。那么</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = sin(v);
</code></pre><p>和</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));
</code></pre><p>是一样的</p>
<p>有时一个参数是浮点型而剩下的都是 <code class="notranslate" translate="no">T</code> ，意思是那个浮点数据会作为所有其他参数的一个新分量。
例如如果 <code class="notranslate" translate="no">v1</code> 和 <code class="notranslate" translate="no">v2</code> 是 <code class="notranslate" translate="no">vec4</code> 同时 <code class="notranslate" translate="no">f</code> 是浮点型，那么</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = mix(v1, v2, f);
</code></pre><p>和</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = vec4(
  mix(v1.x, v2.x, f),
  mix(v1.y, v2.y, f),
  mix(v1.z, v2.z, f),
  mix(v1.w, v2.w, f));
</code></pre><p>等价</p>
<p>你可以在<a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf">WebGL 引用表</a>
最后一页看到所有GLSL方法的列表。如果你喜欢干货以更详细的东西你可以看看
<a href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL 规范</a>。</p>
<h2 id="-">总结</h2>
<p>这是当前系列文章的重点。WebGL的全部内容就是创建不同的着色器，向着色器提供数据然后调用<code class="notranslate" translate="no">gl.drawArrays</code>
 或 <code class="notranslate" translate="no">gl.drawElements</code> 让WebGL调用当前顶点着色器处理每个顶点，调用当前片段着色器渲染每个像素。</p>
<p>实际上创建着色器需要为数不多的几行代码，并且在大多数WebGL应用程序中都相似，
因此一旦写完几乎可以不再关心它们了。<a href="webgl-boilerplate.html">在这里介绍如何编译GLSL并链接到着色程序</a>。</p>
<p>如果你才开始学习WebGL，这里有两个方向可以选择。如果你对图像处理感兴趣我可以向你展示
<a href="webgl-image-processing.html">如何实现二维图像处理</a>。如果你对平移，旋转，缩放以及3D感兴趣，
那就<a href="webgl-2d-translation.html">从这里开始吧</a>。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shaders-and-glsl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-shaders-and-glsl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL 工作原理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL 着色器和GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>图像处理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL 图像处理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL 进一步处理图像</a></li>
        </ul>
  <li>二维平移，旋转，缩放和矩阵运算</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL 二维平移</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL 二维旋转</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL 二维缩放</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL 二维矩阵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL 三维正射投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL 三维透视投影</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL 三维相机</a></li>
        </ul>
  <li>光照</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL 三维方向光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL 三维点光源</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL 三维聚光灯</a></li>
        </ul>
  <li>组织和重构</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL 码少趣多</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL 绘制多个物体</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL 场景图</a></li>
        </ul>
  <li>几何</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL 三维几何加工</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj.html">WebGL 加载 .obj 文件</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">WebGL 加载带 .mtl 的 .obj 文件</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL 三维纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL 数据纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL 使用多个纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL 纹理映射的透视纠正</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">平面的和透视的投影映射</a></li>
        </ul>
  <li>渲染到纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL 渲染到纹理</a></li>
        </ul>
  <li>阴影</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-shadows.html">阴影</a></li>
        </ul>
  <li>技术</li>
        <ul>
            <li>二维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL 二维DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL 二维矩阵栈</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-sprites.html">精灵</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL 雾</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-picking.html">抓取 (点击的东西)</a></li>
        </ul>
  <li>文字</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL 文字 - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL 文字 - 二维Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL 文字 - 使用纹理</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL 文字 - 使用字形纹理</a></li>
        </ul>
  <li>纹理</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>建议</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">WebGL 最小的程序</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">无数据绘图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>优化</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-indexed-vertices.html">顶点索引 （gl.drawElements)</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-instanced-drawing.html">实例化绘制</a></li>
        </ul>
  <li>杂项</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL 设置和安装</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL 样板</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL 重置画布尺寸</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL 动画</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-points-lines-triangles.html">WebGL 点、线和三角</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html">可视化相机</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL 和阿尔法通道</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL 2D vs 3D 库</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL 错误模式</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL 矩阵 vs 数学中的矩阵</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#screenshot">截屏</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#preservedrawingbuffer">防止画布被清空</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#tabindex">在画布中获取键盘输入</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-tips.html#html-background">将 WebGL 作为 HTML 的背景</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cross-platform-issues.html">WebGL 跨平台相关问题</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>参考</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">WebGL 属性</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">WebGL 纹理单元</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-framebuffers.html">WebGL 帧缓冲</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-readpixels.html">WebGL readPixels</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-references.html">WebGL 参考</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API 帮助文档</a></li>
  <li><a href="https://twgljs.org">TWGL, 一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
    <div>有疑问? <a href="https://stackoverflow.com/questions/tagged/webgl">在stackoverflow上提问</a>.</div>
    <div>Issue/Bug? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">在GitHub上提issue</a>.</div>
    <div class="lesson-comment-notes">
       使用 <b>&lt;pre&gt;&lt;code&gt;</b> 代码 <b>&lt;/code&gt;&lt;/pre&gt;</b> 的格式编写代码块
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 着色器和GLSL';
            var disqus_title = 'WebGL 着色器和GLSL';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "感谢 <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>的 <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} 次贡献</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



