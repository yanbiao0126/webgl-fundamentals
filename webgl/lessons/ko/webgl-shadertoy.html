<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-shadertoy.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Shadertoy 셰이더">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ko.jpg">

<meta property="og:title" content="WebGL Shadertoy">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ko.jpg">
<meta property="og:description" content="Shadertoy 셰이더">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Shadertoy">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html">
<meta name="twitter:description" content="Shadertoy 셰이더">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shadertoy_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html",
      "inLanguage":"ko",
      "name":"WebGL Shadertoy",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Shadertoy</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadertoy.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-shadertoy.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shadertoy.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shadertoy.html">
  <link rel="alternate" hreflang="uk" href="https://webglfundamentals.org/webgl/lessons/uk/webgl-shadertoy.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shadertoy.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shadertoy.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-shadertoy.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shadertoy.html" >Русский</a>
    <option value="/webgl/lessons/uk/webgl-shadertoy.html" >Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Shadertoy</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 <a href="webgl-fundamentals.html">기초</a>로 시작한 다른 글을 이미 읽었다고 가정합니다.
아직 읽지 않았다면 거기부터 시작해주세요.</p>
<p><a href="webgl-drawing-without-data.html">데이터 없이 그리기에 대한 글</a>에서 정점 셰이더를 사용하여 데이터 없이 그리는 예제들을 보여드렸습니다.
이 글은 프래그먼트 셰이더를 사용하여 데이터 없이 그리는 것에 관한 겁니다.</p>
<p><a href="webgl-fundamentals.html">제일 첫 번째 글</a>의 코드를 사용하여 수식 없는 간단한 단색 셰이더로 시작해봅시다.</p>
<p>간단한 정점 셰이더:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `
  // 속성은 버퍼에서 데이터를 받습니다.
  attribute vec4 a_position;

  // 모든 셰이더는 main 함수를 가집니다.
  void main() {

    // gl_Position은 정점 셰이더가 설정을 담당하는 특수 변수입니다.
    gl_Position = a_position;
  }
`;
</code></pre>
<p>간단한 프래그먼트 셰이더:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `
  precision highp float;
  void main() {
    // gl_FragColor는 프래그먼트 셰이더가 설정을 담당하는 특수 변수입니다.

    gl_FragColor = vec4(1, 0, 0.5, 1); // 자주색 반환
  }
`;
</code></pre>
<p>셰이더를 컴파일하고 연결한 다음 <code class="notranslate" translate="no">a_position</code> 속성의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  // WebGL 컨텐스트 가져오기
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector(&quot;#canvas&quot;);
  const gl = canvas.getContext(&quot;webgl&quot;);
  if (!gl) {
    return;
  }

  // GLSL 프로그램 설정
  const program = webglUtils.createProgramFromSources(gl, [vs, fs]);

  // 정점 데이터가 어디로 가야 하는지 탐색
  const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p>그리고 x와 y의 -1에서 +1까지의 클립 공간에 사각형을 만드는 2개의 삼각형으로 버퍼를 채웁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // 3개의 2D 클립 공간 포인트를 넣을 버퍼 생성
  const positionBuffer = gl.createBuffer();

  // ARRAY_BUFFER에 바인딩 (ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // 클립 공간을 덮는 2개의 삼각형으로 채우기
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  // 첫 번째 삼각형
     1, -1,
    -1,  1,
    -1,  1,  // 두 번째 삼각형
     1, -1,
     1,  1,
  ]), gl.STATIC_DRAW);
</code></pre>
<p>그런 다음 그립니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // 클립 공간에서 픽셀로 변환하는 방법을 WebGL에 지시
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // 프로그램(셰이더 쌍)을 사용하도록 지시
  gl.useProgram(program);

  // 속성 활성화
  gl.enableVertexAttribArray(positionAttributeLocation);

  // positionBuffer 바인딩
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // positionBuffer(ARRAY_BUFFER)에서 데이터 가져오는 방법을 속성에 지시
  gl.vertexAttribPointer(
      positionAttributeLocation,
      2,          // 반복마다 2개의 컴포넌트
      gl.FLOAT,   // 데이터는 32비트 부동 소수점
      false,      // 데이터 정규화 안 함
      0,          // 0 = 다음 위치를 가져오기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동
      0,          // 버퍼의 처음부터 시작
  );

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // 오프셋
      6,     // 처리할 정점 수
  );
</code></pre>
<p>그리고 당연히 캔버스를 덮는 단색이 생깁니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-solid.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-solid.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p><a href="webgl-how-it-works.html">WebGL 작동 방식에 대한 글</a>에서 각 정점에 대해 색상을 제공하여 더 많은 색상을 추가했습니다.
<a href="webgl-3d-textures.html">텍스처에 관한 글</a>에서는 텍스처와 텍스처 좌표를 제공하여 더 많은 색상을 추가했습니다.
그렇다면 더 이상의 데이터 없이 단색 이상의 무언가를 얻으려면 어떻게 해야 할까요?
WebGL은 현재 그려지고 있는 픽셀의 <strong>픽셀 좌표</strong>와 동일한 <code class="notranslate" translate="no">gl_FragCoord</code>라는 변수를 제공합니다.</p>
<p>색상을 계산하는 데에 사용하도록 프래그먼트 셰이더를 바꿔봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `
  precision highp float;
  void main() {
    // gl_FragColor는 프래그먼트 셰이더가 설정을 담당하는 특수 변수입니다.

-    gl_FragColor = vec4(1, 0, 0.5, 1); // 자주색 반환
+    gl_FragColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
  }
`;
</code></pre>
<p>위에서 언급한 것처럼 <code class="notranslate" translate="no">gl_FragCoord</code>는 <strong>픽셀 좌표</strong>이기 때문에 캔버스 전체에 걸쳐 계산됩니다.
<code class="notranslate" translate="no">gl_FragCoord</code>가 0에서 50사이일 때 50으로 나누면 0에서 1사이의 값을 얻는데요.
그리고 <code class="notranslate" translate="no">fract</code>를 사용하여 소수 부부만 유지합니다.
예를 들어 <code class="notranslate" translate="no">gl_FragCoord</code>가 75인 경우, 75 / 50 = 1.5, fract(1.5) = 0.5, 이렇게 50픽셀마다 0에서 1사이의 값을 얻습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-gl-fragcoord.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-gl-fragcoord.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>위에서 볼 수 있듯이 50픽셀마다 빨간색과 초록색이 교차하여 나타납니다.</p>
<p>이제 이런 설정을 통해 더 멋진 이미지를 위한 더 복잡한 수식을 만들 수 있습니다.
하지만 한 가지 문제가 있는데 캔버스가 얼마나 큰지 모르기 때문에 특정한 크기로 하드 코딩해야 합니다.
이 문제를 해결하기 위해 캔버스의 크기를 전달한 다음 <code class="notranslate" translate="no">gl_FragCoord</code>를 해당 크기로 나누면 캔버스 크기에 관계없이 0에서 1사이의 값을 얻을 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `
  precision highp float;

+  uniform vec2 u_resolution;

  void main() {
    // gl_FragColor는 프래그먼트 셰이더가 설정을 담당하는 특수 변수입니다.

-    gl_FragColor = vec4(fract(gl_FragCoord.xy / 50.0), 0, 1);
+    gl_FragColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>그리고 유니폼을 찾아 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 정점 데이터가 어디로 가야 하는지 탐색
const positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);

+// 유니폼 위치 탐색
+const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);

...

+gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

gl.drawArrays(
    gl.TRIANGLES,
    0,     // 오프셋
    6,     // 처리할 정점 수
);

...
</code></pre>
<p>이는 해상도에 상관없이 캔버스에 맞게 빨간색과 초록색이 퍼지도록 만들어줍니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-resolution.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-resolution.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>픽셀 좌표의 마우스 위치도 전달해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `
  precision highp float;

  uniform vec2 u_resolution;
+  uniform vec2 u_mouse;

  void main() {
    // gl_FragColor는 프래그먼트 셰이더가 설정을 담당하는 특수 변수입니다.

-    gl_FragColor = vec4(fract(gl_FragCoord.xy / u_resolution), 0, 1);
:   gl_FragColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
  }
`;
</code></pre>
<p>그런 다음 유니폼의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 유니폼 위치 탐색
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
+const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
</code></pre>
<p>그리고 마우스를 추적합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;

function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // WebGL에서 0은 하단
  render();
}

canvas.addEventListener(&#39;mousemove&#39;, setMousePosition);
</code></pre>
<p>다시 유니폼을 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
+gl.uniform2f(mouseLocation, mouseX, mouseY);
</code></pre>
<p>또한 코드를 바꿔서 마우스 위치가 바뀔 때 렌더링합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // WebGL에서 0은 하단
+  render();
}

+function render() {
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // 오프셋
      6,     // 처리할 정점 수
  );
+}
+render();
</code></pre>
<p>하는 김에 터치도 처리합시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">canvas.addEventListener(&#39;mousemove&#39;, setMousePosition);
+canvas.addEventListener(&#39;touchstart&#39;, (e) =&gt; {
+  e.preventDefault();
+}, {passive: false});
+canvas.addEventListener(&#39;touchmove&#39;, (e) =&gt; {
+  e.preventDefault();
+  setMousePosition(e.touches[0]);
+}, {passive: false});
</code></pre>
<p>이제 예제 위에서 마우스를 움직이면 이미지에 움직이는 것을 볼 수 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-mouse.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-mouse.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>마지막으로 애니메이션이 가능하도록 하고 싶기 때문에 계산에 추가하여 사용할 수 있는 시간 값을 전달합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
+  uniform float u_time;

  void main() {
    // gl_FragColor는 프래그먼트 셰이더가 설정을 담당하는 특수 변수입니다.

-    gl_FragColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), 0, 1);
+    gl_FragColor = vec4(fract((gl_FragCoord.xy - u_mouse) / u_resolution), fract(u_time), 1);
  }
`;
</code></pre>
<p>그러면 이제 파란색 채널이 시간에 맞춰 깜박입니다.
유니폼을 찾고 <a href="webgl-animation.html">requestAnimationFrame 루프</a> 내에서 설정하기만 하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 유니폼 위치 탐색
const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
+const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);

...

-function render() {
+function render(time) {
+  time *= 0.001;  // 초 단위로 변환

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  ...

  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
  gl.uniform2f(mouseLocation, mouseX, mouseY);
+  gl.uniform1f(timeLocation, time);

  gl.drawArrays(
      gl.TRIANGLES,
      0,     // 오프셋
      6,     // 처리할 정점 수
  );

+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
-render();
</code></pre>
<p>또한 계속해서 렌더링하기 때문에 mousemove에서 렌더링할 필요가 없습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let mouseX = 0;
let mouseY = 0;
canvas.addEventListener(&#39;mousemove&#39;, (e) =&gt; {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;  // WebGL에서 0은 하단
-  render();
});
</code></pre>
<p>그러면 간단하지만 지루한 애니메이션을 얻게 됩니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy-w-time.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy-w-time.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>이제 <a href="https://shadertoy.com">Shadertoy.com</a>에서 셰이더를 가져올 수 있습니다.
Shadertoy 셰이더는 <code class="notranslate" translate="no">mainImage</code>라는 함수를 이런 형식으로 제공합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void mainImage(out vec4 fragColor, in vec2 fragCoord)
{    
}
</code></pre>
<p>일반적으로 <code class="notranslate" translate="no">gl_FragColor</code>를 설정하는 것처럼 <code class="notranslate" translate="no">fragColor</code>를 설정면 되고 <code class="notranslate" translate="no">fragCoord</code>는 <code class="notranslate" translate="no">gl_FragCoord</code>와 동일합니다.
이 함수를 추가하면 Shadertoy는 <code class="notranslate" translate="no">mainImage</code> 호출 전후에 추가 작업을 수행할 수 있을 뿐만 아니라 구조를 강제할 수 있습니다.
이걸 사용하려면 그냥 이렇게 호출하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision highp float;

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

//---여기에 shadertoy 코드 삽입--

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
</code></pre>
<p>그 외에는 Shadertoy가 유니폼 이름으로 <code class="notranslate" translate="no">iResolution</code>, <code class="notranslate" translate="no">iMouse</code>, <code class="notranslate" translate="no">iTime</code>를 사용하므로 이름을 바꾸겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision highp float;

-uniform vec2 u_resolution;
-uniform vec2 u_mouse;
-uniform float u_time;
+uniform vec2 iResolution;
+uniform vec2 iMouse;
+uniform float iTime;

//---여기에 shadertoy 코드 삽입--

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
</code></pre>
<p>그리고 새로운 이름으로 유니폼의 위치를 찾습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 유니폼 위치 탐색
-const resolutionLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
-const mouseLocation = gl.getUniformLocation(program, &quot;u_mouse&quot;);
-const timeLocation = gl.getUniformLocation(program, &quot;u_time&quot;);
+const resolutionLocation = gl.getUniformLocation(program, &quot;iResolution&quot;);
+const mouseLocation = gl.getUniformLocation(program, &quot;iMouse&quot;);
+const timeLocation = gl.getUniformLocation(program, &quot;iTime&quot;);
</code></pre>
<p><a href="https://www.shadertoy.com/view/3l23Rh">이 shadertoy 셰이더</a>를 가져가서 위 셰이더의 <code class="notranslate" translate="no">//---여기에 shadertoy 코드 삽입--</code>에 붙여넣으면 다음과 같이 표시됩니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadertoy.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadertoy.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>데이터가 없다니 놀랍도록 아름다운 이미지네요!</p>
<p>위 샘플은 마우스가 캔버스 위에 있거나 터치할 때만 렌더링하도록 만들어졌습니다.
이는 위 이미지를 그릴 때 필요한 수식이 굉장히 복잡하고 느려서 계속 실행하면 페이지 사용하기 매우 힘들어지기 때문입니다.
만약 엄청나게 빠른 GPU를 가지고 있다면 이미지는 부드럽게 실행될 겁니다.
제 노트북에서는 느리고 버벅입니다.</p>
<p>이건 굉장히 중요한 포인트를 알려주는데요.
<strong>Shadertoy 셰이더는 모범 사례가 아닙니다.</strong>
Shadertoy는 <em>&quot;데이터가 없고 입력을 거의 받지 않는 함수만 있을 때 흥미롭고 아름다운 이미지를 만들 수 있을까?&quot;</em>라는 퍼즐이자 도전입니다.
성능이 좋은 WebGL을 만드는 방법이 아닙니다.</p>
<p>한 가지 <a href="https://www.shadertoy.com/view/4sS3zG">놀라운 shadertoy 셰이더</a>를 예로 들어 보겠습니다.</p>
<div class="webgl_center"><img src="../resources/shadertoy-dolphin.png" style="width: 639px;"></div>

<p>이는 아름답지만 제 중급 노트북의 작은 창(640x360)에서 초당 19프레임으로 작동합니다.
창을 전체화면으로 확장하면 초당 2~3프레임으로 실행됩니다.
더 높은 스펙의 컴퓨터에서 테스트해도 여전히 640x360에서 45프레임이고 전체화면에서 10프레임에 불과합니다.</p>
<p>이 게임과 비교해보면 이것도 상당히 아릅답지만 저전력 GPU에서 초당 30~60프레임으로 실행됩니다.</p>
<iframe class="webgl_center" style="width:560px; height: 360px;" src="https://www.youtube-nocookie.com/embed/7v9gZK9HqqI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>이는 게임이 복잡한 수식 대신에 텍스처를 사용한 삼각형으로 그리는 모범 사례를 사용했기 때문입니다.</p>
<p>그러니 부디 명심해주시길 바랍니다.
Shadertoy에 있는 예제들은 데이터가 거의 없는 극한의 제약 아래 만들어지고 예쁜 그림을 그리는 복잡한 함수라는 것을 알기에 정말로 놀랍습니다.
또한 많은 수학을 배울 수 있는 좋은 방법입니다.</p>
<p>하지만 성능 좋은 WebGL을 얻을 수 있는 방법은 아닙니다.
그러니 꼭 명심해주세요.</p>
<p>그러지 않고 더 많은 Shadertoy 셰이더를 실행하고 싶다면 몇 가지 유니폼을 더 제공해야 합니다.
다음은 Shadertoy가 제공하는 유니폼 목록입니다.</p>
<div class="webgl_center"><table  class="tabular-data tabular-data1">
<thead><tr><td>타입</td><td>이름</td><td>위치</td><td>설명</td></tr></thead>
<tbody>
<tr><td><b>vec3</b></td><td><b>iResolution</b></td><td>image / buffer</td><td>뷰포트 해상도 (z는 픽셀 종횡비, 일반적으로 1.0)</td></tr>
<tr><td><b>float</b></td><td><b>iTime</b></td><td>image / sound / buffer</td><td>초 단위 현재 시간</td></tr>
<tr><td><b>float</b></td><td><b>iTimeDelta</b></td><td>image / buffer</td><td>프레임 렌더링에 걸리는 초 단위 시간</td></tr>
<tr><td><b>int</b></td><td><b>iFrame</b></td><td>image / buffer</td><td>현재 프레임</td></tr>
<tr><td><b>float</b></td><td><b>iFrameRate</b></td><td>image / buffer</td><td>초당 렌더링되는 프레임 수</td></tr>
<tr><td><b>float</b></td><td><b>iChannelTime[4]</b></td><td>image / buffer</td><td>비디오나 오디오인 경우 초 단위 채널 시간</td></tr>
<tr><td><b>vec3</b></td><td><b>iChannelResolution[4]</b></td><td>image / buffer / sound</td><td>각 채널에 대한 입력 텍스처 해상도</td></tr>
<tr><td><b>vec4</b></td><td><b>iMouse</b></td><td>image / buffer</td><td>xy = 현재 픽셀 좌표 (if LMB is down), zw = 클릭 픽셀</td></tr>
<tr><td><b>sampler2D</b></td><td><b>iChannel{i}</b></td><td>image / buffer / sound</td><td>입력 텍스처 i에 대한 샘플러</td></tr>
<tr><td><b>vec4</b></td><td><b>iDate</b></td><td>image / buffer / sound</td><td>Year, month, day, time in seconds in .xyzw</td></tr>
<tr><td><b>float</b></td><td><b>iSampleRate</b></td><td>image / buffer / sound</td><td>사운드 샘플 레이트 (일반적으로 44100)</td></tr>
</tbody></table></div>

<p><code class="notranslate" translate="no">iMouse</code>와 <code class="notranslate" translate="no">iResolution</code>은 각각 <code class="notranslate" translate="no">vec4</code>와 <code class="notranslate" translate="no">vec3</code>로 되어 있으므로 이에 맞도록 조정해야할 수 있습니다.</p>
<p><code class="notranslate" translate="no">iChannel</code>은 텍스처이기 때문에 셰이더에서 사용하려면 <a href="webgl-3d-textures.html">텍스처</a>를 제공해야 합니다.</p>
<p>또한 Shadertoy로 여러 셰이더를 사용하여 오프스크린 텍스처를 렌더링할 수 있으므로 셰이더에 이런 게 필요할 경우 <a href="webgl-render-to-texture.html">렌더링할 텍스처</a>를 설정해야 합니다.</p>
<p>&quot;위치&quot; 열은 어느 셰이더에서 어떤 유니폼을 사용할 수 있는지 나타냅니다.
&quot;image&quot;는 캔버스에 렌더링하는 셰이더입니다.
&quot;buffer&quot;는 오프스크린 텍스처에 렌더링하는 셰이더입니다.
&quot;sound&quot;는 <a href="https://stackoverflow.com/questions/34859701/how-do-shadertoys-audio-shaders-work">사운드 데이터를 텍스처로 생성할 것으로 예상되는 셰이더</a>입니다.</p>
<p>마지막으로 shadertoy의 일부 셰이더는 <a href="https://webgl2fundamentals.org">WebGL2</a>를 필요로 합니다.</p>
<p>이 글이 Shadertoy 설명에 도움이 되었기를 바랍니다.
놀라운 작품들이 있는 훌륭한 사이트지만 실제로 무슨 일이 일어나는건지 아는 게 좋습니다.
이러한 종류의 셰이더에 사용된 기술에 대해 배우고 싶다면 <a href="&quot;https://www.iquilezles.org/www/index.htm">Shadertoy를 만든 사람의 블로그</a>와 <a href="https://thebookofshaders.com/">The Book of Shaders</a> 등의 좋은 리소스가 있는데요.
성능 좋은 앱이나 게임이 아니라 shadertoy에 사용되는 종류의 셰이더만 다루기 때문에 오해의 소지가 있지만 그래도 여전히 좋은 리소스입니다!</p>
<div class="webgl_bottombar" id="pixel-coords">
<h3>픽셀 좌표</h3>
<p>
WebGL에서 픽셀 좌표는 가장자리를 참조합니다.
예를 들어 3x2 픽셀 크기의 캔버스의 경우 왼쪽에서 2픽셀이고 아래쪽에서 1픽셀인 <code class="notranslate" translate="no">gl_FragCoord</code>의 값은 2.5와 1.5가 됩니다.
</p>
<div class="webgl_center"><img src="../resources/webgl-pixels.svg" style="width: 500px;"></div>
</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shadertoy.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shadertoy.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shadertoy.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadertoy.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-shadertoy.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shadertoy.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shadertoy.html" >Русский</a>
    <option value="/webgl/lessons/uk/webgl-shadertoy.html" >Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadertoy.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로드</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일이 있는 .obj 로드</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">인스턴스 드로잉</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
<div class="lesson-comment-notes">
  코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Shadertoy';
            var disqus_title = 'WebGL Shadertoy';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



