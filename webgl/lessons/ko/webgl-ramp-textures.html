<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-ramp-textures.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="램프 텍스처 사용하기">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ko.jpg">

<meta property="og:title" content="WebGL 램프 텍스처">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ko.jpg">
<meta property="og:description" content="램프 텍스처 사용하기">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 램프 텍스처">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html">
<meta name="twitter:description" content="램프 텍스처 사용하기">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-ramp-textures_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html",
      "inLanguage":"ko",
      "name":"WebGL 램프 텍스처",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 램프 텍스처</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-ramp-textures.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-ramp-textures.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-ramp-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-ramp-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-ramp-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-ramp-textures.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-ramp-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-ramp-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-ramp-textures.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-ramp-textures.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 램프 텍스처</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL에서 중요한 사실은 <a href="webgl-3d-textures.html">텍스처가 텍스처에 대한 글</a>에서 다룬 것처럼 삼각형에 직접 적용되는 게 아니라는 겁니다.
텍스처는 랜덤 접근 데이터 배열이며, 일반적으로 데이터의 2D 배열입니다.
따라서 데이터의 랜덤 접근 배열을 사용할 수 있는 솔루션은 텍스처를 사용할 수 있는 곳입니다.</p>
<p><a href="webgl-3d-lighting-directional.html">방향성 조명에 대한 글</a>에서 <em>스칼라곱</em>을 사용하여 두 벡터 사이의 각도를 계산하는 방법을 다뤘었습니다.
모델 표면의 법선에 대한 조명 방향의 <em>스칼라곱</em>을 계산했는데요.
이는 두 벡터 사이 각도의 코사인을 제공합니다.
코사인은 -1에서 +1사이의 값이며 색상에 직접 곱했습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float light = dot(normal, u_reverseLightDirection);

gl_FragColor = u_color;
gl_FragColor.rgb *= light;
</code></pre>
<p>이렇게 하면 빛에서 멀어질수록 색상이 어두워집니다.</p>
<p>스칼라곱을 직접 사용하는 대신에 1차원 텍스처에서 값을 찾는 데 사용하면 어떨까요?</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// 정점 셰이더에서 전달됩니다.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
+uniform sampler2D u_ramp;

void main() {
  // v_normal이 베링이기 때문에 보간되므로 단위 벡터가 아닙니다.
  // 정규화하면 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);

-  float light = dot(normal, u_reverseLightDirection);
+  float cosAngle = dot(normal, u_reverseLightDirection);
+
+  // -1 &lt;-&gt; 1에서 0 &lt;-&gt; 1로 변환
+  float u = cosAngle * 0.5 + 0.5;
+
+  // 텍스처 좌표 만들기
+  vec2 uv = vec2(u, 0.5);
+
+  // 1차원 텍스처에서 값 조회
+  vec4 rampColor = texture2D(u_ramp, uv);
+
  gl_FragColor = u_color;
-  gl_FragColor.rgb *= light;
+  gl_FragColor *= rampColor;
}
</code></pre>
<p>텍스처를 만들어야 합니다.
2x1 텍스처로 시작해봅시다.
텍셀당 1바이트만 사용하여 모노크롬 텍스처를 제공하는 <code class="notranslate" translate="no">LUMINANCE</code> 포맷을 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texImage2D(
    gl.TEXTURE_2D,     // 대상
    0,                 // 밉 레벨
    gl.LUMINANCE,      // 내부 포맷
    2,                 // 너비
    1,                 // 높이
    0,                 // 테두리
    gl.LUMINANCE,      // 포맷
    gl.UNSIGNED_BYTE,  // 타입
    new Uint8Array([90, 255]));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>위에서 두 픽셀의 색상은 어두운 회색(90)과 흰색(255)입니다.
또한 필터링이 없도록 텍스처 매개변수를 설정합니다.</p>
<p>새로운 텍스처에 대한 샘플을 수정하려면 <code class="notranslate" translate="no">u_ramp</code> 유니폼을 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var worldViewProjectionLocation = gl.getUniformLocation(program, &quot;u_worldViewProjection&quot;);
var worldInverseTransposeLocation = gl.getUniformLocation(program, &quot;u_worldInverseTranspose&quot;);
var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
+var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
var reverseLightDirectionLocation =
    gl.getUniformLocation(program, &quot;u_reverseLightDirection&quot;);
</code></pre>
<p>그리고 렌더링할 때 텍스처를 설정해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 활성 텍스처 유닛 0에 텍스처 바인딩
gl.activeTexture(gl.TEXTURE0 + 0);
gl.bindTexture(gl.TEXTURE_2D, tex);
// u_ramp가 텍스처 유닛 0에서 텍스처를 사용해야 한다고 셰이더에 알림
gl.uniform1i(rampLocation, 0);
</code></pre>
<p>조명 샘플의 3D <code class="notranslate" translate="no">F</code> 데이터를 저 폴리곤 머리 데이터로 교체했습니다.
실행하면 이렇게 됩니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-texture.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>모델을 회전해보면 <a href="https://ko.wikipedia.org/wiki/%EC%85%80_%EC%85%B0%EC%9D%B4%EB%94%A9">툰 셰이딩</a>과 비슷하게 보이는 걸 확인할 수 있습니다.</p>
<p>위 예제에서 텍스처 필터링을 <code class="notranslate" translate="no">NEAREST</code>로 설정하여 텍스처에서 가장 가까운 텍셀을 색상으로 선택합니다.
단 2개의 텍셀만 있기 때문에 표면이 조명에서 멀어지면 첫 번째 색상(어두운 회색)을 얻고, 표면이 조명에서 가까워지면 두 번째 색상(흰색)을 얻게 됩니다.
색상은 <code class="notranslate" translate="no">light</code>에 사용했던 것처럼 <code class="notranslate" translate="no">gl_FragColor</code>로 곱해집니다.</p>
<p>생각해보니 <code class="notranslate" translate="no">LINEAR</code> 필터링으로 전환하면 텍스처를 사용하기 전과 같은 결과가 나와야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
-gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-texture-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-texture-linear.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>비슷하게 보이지만 실제로 나란히 놓고 비교해보면...</p>
<div class="webgl_center"><img src="../resources/ramp-vs-light.png" style="width: 598px;"></div>

<p>동일하지 않다는 것을 알 수 있습니다.
어떻게 된 걸까요?</p>
<p><code class="notranslate" translate="no">LINEAR</code> 필터링은 픽셀 사이를 혼합하는데요.
선형 필터링을 사용한 두 픽셀 텍스처를 확대해보면 문제가 뭔지 알게 됩니다.</p>
<div class="webgl_center"><img src="../resources/linear-texture-interpolation.svg" style="width: 500px;"></div>
<div class="webgl_center">램프의 텍스처 좌표 범위</div>

<p>보간없이 양쪽에 0.5픽셀이 있습니다.
텍스처에서 <code class="notranslate" translate="no">TEXTURE_WRAP_S</code>가 <code class="notranslate" translate="no">REPEAT</code>로 설정되었다고 상상해보세요.
그러면 초록색이 왼쪽으로 반복되는 것처럼 빨간색 픽셀이 초록색을 향해 선형적 혼합될 것이라 예상했는데요.
하지만 <code class="notranslate" translate="no">CLAMP_TO_EDGE</code>를 사용하고 있기 때문에 왼쪽이 더 빨갛습니다.</p>
<p>램프를 실제로 얻으려면 해당 중심 범위에서 값을 선택하면 됩니다.
셰이더에서 약간의 수식으로 이를 수행할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// 정점 셰이더에서 전달됩니다.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
uniform sampler2D u_ramp;
+uniform vec2 u_rampSize;

void main() {
  // v_normal이 베링이기 보간되므로 단위 벡터가 아닙니다.
  // 정규화하면 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);

  float cosAngle = dot(normal, u_reverseLightDirection);

  // -1 &lt;-&gt; 1에서 0 &lt;-&gt; 1로 변환
  float u = cosAngle * 0.5 + 0.5;

  // 텍스처 좌표 만들기
  vec2 uv = vec2(u, 0.5);

+  // 램프의 크기로 크기 조정
+  vec2 texelRange = uv * (u_rampSize - 1.0);
+
+  // 텍셀의 절반만큼 오프셋하고 텍스처 좌표로 변환
+  vec2 rampUV = (texelRange + 0.5) / u_rampSize;

-  vec4 rampColor = texture2D(u_ramp, uv);
+  vec4 rampColor = texture2D(u_ramp, rampUV);

  gl_FragColor = u_color;
  gl_FragColor *= rampColor;
}
</code></pre>
<p>위에서 우리는 기본적으로 UV 좌표의 크기를 조정하여 텍스처 너비보다 1만큼 작은 0에서 1사이가 됩니다.
그런 다음 픽셀에 0.5를 추가하고 다시 정규화된 텍스처 좌표로 변환합니다.</p>
<p><code class="notranslate" translate="no">u_rampSize</code>의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
+var rampSizeLocation = gl.getUniformLocation(program, &quot;u_rampSize&quot;);
</code></pre>
<p>그리고 렌더링할 때 이를 설정해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 활성 텍스처 유닛 0에 텍스처 바인딩
gl.activeTexture(gl.TEXTURE0 + 0);
gl.bindTexture(gl.TEXTURE_2D, tex);
// u_ramp가 텍스처 유닛 0에서 텍스처를 사용해야 한다고 셰이더에 알림
gl.uniform1i(rampLocation, 0);
+gl.uniform2fv(rampSizeLocation, [2, 1]);
</code></pre>
<p>실행하기 전에 램프 텍스처가 있을 때와 없을 때를 비교할 수 있도록 플래그를 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// 정점 셰이더에서 전달됩니다.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
uniform sampler2D u_ramp;
uniform vec2 u_rampSize;
+uniform bool u_useRampTexture;

void main() {
  // v_normal이 베링이기 보간되므로 단위 벡터가 아닙니다.
  // 정규화하면 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);

  float cosAngle = dot(normal, u_reverseLightDirection);

  // -1 &lt;-&gt; 1에서 0 &lt;-&gt; 1로 변환
  float u = cosAngle * 0.5 + 0.5;

  // 텍스처 좌표 만들기
  vec2 uv = vec2(u, 0.5);

  // 램프의 크기로 크기 조정
  vec2 texelRange = uv * (u_rampSize - 1.0);

  // 텍셀의 절반만큼 오프셋하고 텍스처 좌표로 변환
  vec2 rampUV = (texelRange + 0.5) / u_rampSize;

  vec4 rampColor = texture2D(u_ramp, rampUV);

+  if (!u_useRampTexture) {
+    rampColor = vec4(u, u, u, 1);
+  }

  gl_FragColor = u_color;
  gl_FragColor *= rampColor;
}
</code></pre>
<p>유니폼의 위치도 찾을 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
var rampSizeLocation = gl.getUniformLocation(program, &quot;u_rampSize&quot;);
+var useRampTextureLocation = gl.getUniformLocation(program, &quot;u_useRampTexture&quot;);
</code></pre>
<p>그리고 그걸 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var data = {
  useRampTexture: true,
};

...

// 액티브 텍스처 유닛 0에 텍스처 바인딩
gl.activeTexture(gl.TEXTURE0 + 0);
gl.bindTexture(gl.TEXTURE_2D, tex);
// u_ramp가 텍스처 유닛 0의 텍스처를 사용해야 한다고 셰이더에 알림
gl.uniform1i(rampLocation, 0);
gl.uniform2fv(rampSizeLocation, [2, 1]);

+gl.uniform1i(useRampTextureLocation, data.useRampTexture);
</code></pre>
<p>이를 통해 기존 조명 방식과 새로운 램프 텍스처 방식이 일치하는 것을 볼 수 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-texture-issue-confirm.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-texture-issue-confirm.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>&quot;useRampTexture&quot; 체크 박스를 클릭하면 현재 두 기술이 일치하기 때문에 변화가 없습니다.</p>
<blockquote>
<p>참고: 일반적으로 셰이더에서 <code class="notranslate" translate="no">u_useRampTexture</code>와 같은 조건문을 사용하는 것은 권장되지 않는데요.
대신에 일반 조명과 램프 텍스처를 사용하는 셰이더 프로그램을 각각 만드는 게 좋습니다.
안타깝지만 코드는 <a href="webgl-less-code-more-fun.html">외부 도우미 라이브러리</a>를 사용하고 있지 않기 때문에 2개의 셰이더 프로그램을 지원하기 위해 꽤 많이 바뀔 겁니다.
각 프로그램은 고유한 위치 세트가 필요합니다.
하지만 그렇게 많이 변경하면 이 글의 요점에서 벗어날 수 있기 때문에 여기서는 조건문을 사용하기로 결정했습니다.
일반적으로 저는 셰이더에서 기능을 선택하는 조건문을 피하고 대신에 다른 기능을 위한 다른 셰이더를 생성합니다.</p>
</blockquote>
<p>참고: 이 수식은 <code class="notranslate" translate="no">LINEAR</code> 필터링을 사용하는 경우에만 중요합니다.
<code class="notranslate" translate="no">NEAREST</code> 필터링을 사용하고 있다면 원래 수식이 필요합니다.</p>
<p>이제 램프 수식이 맞다는 것을 알았으니 다양한 램프 텍스처를 만들어 보겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+// 0 ~ 127 요소는 64 ~ 191이고 128 ~ 255 요소는 모두 255인 배열을 만듭니다.
+const smoothSolid = new Array(256).fill(255);
+for (let i = 0; i &lt; 128; ++i) {
+  smoothSolid[i] = 64 + i;
+}
+
+const ramps = [
+  { name: &#39;dark-white&#39;,          color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 255] },
+  { name: &#39;dark-white-skewed&#39;,   color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 80, 80, 255, 255] },
+  { name: &#39;normal&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: true,
+    data: [0, 255] },
+  { name: &#39;3-step&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 160, 255] },
+  { name: &#39;4-step&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 140, 200, 255] },
+  { name: &#39;4-step skewed&#39;,       color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 80, 80, 80, 140, 200, 255] },
+  { name: &#39;black-white-black&#39;,   color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 255, 80] },
+  { name: &#39;stripes&#39;,             color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255, 80, 255] },
+  { name: &#39;stripe&#39;,              color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: [80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255] },
+  { name: &#39;smooth-solid&#39;,        color: [0.2, 1, 0.2, 1], format: gl.LUMINANCE, filter: false,
+    data: smoothSolid },
+  { name: &#39;rgb&#39;,                 color: [  1, 1,   1, 1], format: gl.RGB,       filter: true,
+    data: [255, 0, 0, 0, 255, 0, 0, 0, 255] },
+];
+
+var elementsForFormat = {};
+elementsForFormat[gl.LUMINANCE] = 1;
+elementsForFormat[gl.RGB      ] = 3;
+
+ramps.forEach((ramp) =&gt; {
+  const {name, format, filter, data} = ramp;
  var tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
+  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
+  const width = data.length / elementsForFormat[format];
  gl.texImage2D(
      gl.TEXTURE_2D,     // 대상
      0,                 // 밉 레벨
*      format,            // 내부 포맷
*      width,             // 너비
      1,                 // 높이
      0,                 // 테두리
*     format,            // 포맷
      gl.UNSIGNED_BYTE,  // 타입
*      new Uint8Array(data));
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
*  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter ? gl.LINEAR : gl.NEAREST);
*  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter ? gl.LINEAR : gl.NEAREST);
+  ramp.texture = tex;
+  ramp.size = [width, 1];
+});
</code></pre>
<p><code class="notranslate" translate="no">NEAREST</code>와 <code class="notranslate" translate="no">LINEAR</code>를 모두 처리할 수 있도록 셰이더를 만들어 보겠습니다.
위에서 언급한 것처럼 일반적으로 셰이더에서 조건문을 사용하진 않지만, 차이점이 간단하고 조건문 없이 할 수 있다면 셰이더 하나만 사용하는 것을 고려할 겁니다.
그렇게 하기 위해 0.0이나 1.0으로 설정할 부동 소수점 유니폼 <code class="notranslate" translate="no">u_linearAdjust</code>를 추가할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// 정점 셰이더에서 전달됩니다.
varying vec3 v_normal;

uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
uniform sampler2D u_ramp;
uniform vec2 u_rampSize;
-uniform bool u_useRampTexture;
-uniform float u_linearAdjust;  // &quot;linear&quot;인 경우 1.0, &quot;nearest&quot;인 경우 0.0

void main() {
  // v_normal이 베링이기 보간되므로 단위 벡터가 아닙니다.
  // 정규화하면 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);

  float cosAngle = dot(normal, u_reverseLightDirection);

  // -1 &lt;-&gt; 1에서 0 &lt;-&gt; 1로 변환
  float u = cosAngle * 0.5 + 0.5;

  // 텍스처 좌표 만들기
  vec2 uv = vec2(u, 0.5);

  // 램프의 크기로 크기 조정
-  vec2 texelRange = uv * (u_rampSize - 1.0);
+  vec2 texelRange = uv * (u_rampSize - u_linearAdjust);

-  // 텍셀의 절반만큼 오프셋하고 텍스처 좌표로 변환
-  vec2 rampUV = (texelRange + 0.5) / u_rampSize;
+  // &quot;linear&quot;인 경우 텍셀의 절반만큼 오프셋하고 텍스처 좌표로 변환
+  vec2 rampUV = (texelRange + 0.5 * u_linearAdjust) / u_rampSize;

  vec4 rampColor = texture2D(u_ramp, rampUV);

-  if (!u_useRampTexture) {
-    rampColor = vec4(u, u, u, 1);
-  }

  gl_FragColor = u_color;
  gl_FragColor *= rampColor;
}
</code></pre>
<p>초기화할 때 위치를 찾습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
var rampLocation = gl.getUniformLocation(program, &quot;u_ramp&quot;);
var rampSizeLocation = gl.getUniformLocation(program, &quot;u_rampSize&quot;);
+var linearAdjustLocation = gl.getUniformLocation(program, &quot;u_linearAdjust&quot;);
</code></pre>
<p>그리고 렌더링할 때 텍스처 중 하나를 선택합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var data = {
  ramp: 0,
};

...
+const {texture, color, size, filter} = ramps[data.ramp];

// 사용할 색상 설정
-gl.uniform4fv(colorLocation, [0.2, 1, 0.2, 1]);
+gl.uniform4fv(colorLocation, color);

// 조명 방향 설정
gl.uniform3fv(reverseLightDirectionLocation, m4.normalize([-1.75, 0.7, 1]));

// 액티브 텍스처 유닛 0에 텍스처 바인딩
gl.activeTexture(gl.TEXTURE0 + 0);
-gl.bindTexture(gl.TEXTURE_2D, tex);
+gl.bindTexture(gl.TEXTURE_2D, texture);
// u_ramp가 텍스처 유닛 0의 텍스처를 사용해야 한다고 셰이더에 알림
gl.uniform1i(rampLocation, 0);
-gl.uniform2fv(rampSizeLocation, [2, 1]);
+gl.uniform2fv(rampSizeLocation, size);

+// &quot;linear&quot;인 경우 조정
+gl.uniform1f(linearAdjustLocation, filter ? 1 : 0);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-ramp-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-ramp-textures.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>다른 램프 텍스처를 시도하면 이상한 효과를 많이 볼 수 있습니다.
이게 일반적인 조정 셰이더를 만드는 하나의 방법입니다.
다음과 같이 2개의 색상과 임계값을 설정하여 2색 툰 셰이딩 셰이더를 만들 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">uniform vec4 color1;
uniform vec4 color2;
uniform float threshold;

...

  float cosAngle = dot(normal, u_reverseLightDirection);

  // -1 &lt;-&gt; 1에서 0 &lt;-&gt; 1로 변환
  float u = cosAngle * 0.5 + 0.5;

  gl_FragColor = mix(color1, color2, step(cosAngle, threshold));
</code></pre>
<p>그리고 이것은 잘 동작할 겁니다.
하지만 3단계 혹은 4단계 버전을 하고 싶다면 또 다른 셰이더를 작성해야 합니다.
램프 텍스처로 다른 텍스처를 제공할 수 있습니다.
2단계 툰 셰이더를 하려는 경우에도 텍스처에 데이터를 더 많이 혹은 더 적게 넣어서 단계가 발생하는 위치를 조정할 수 있는데요.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">[dark, light]
</code></pre><p>예를 들어 위와 같은 텍스처가 있으면 빛을 향하는 방향과 반대하는 방향 사이의 중간에서 나뉘는 2단계 텍스처를 제공합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">[dark, dark, dark, light, light]
</code></pre><p>하지만 위와 같은 텍스처의 경우 셰이더를 바꾸지 않고도 빛을 향하는 방향과 반대하는 방향 사이의 60% 지점으로 분할을 이동합니다.</p>
<p>툰 셰이딩이나 이상한 효과를 위해 램프 텍스처를 사용하는 이 예제는 여러분에게 유용할 수도 있고 아닐 수도 있지만 더 중요한 점은 텍스처에서 데이터를 찾기 위해 어떤 값을 사용하는 기본 개념입니다.
이렇게 텍스처를 사용하는 것은 단순히 빛 계산을 변환하기 위한 게 아닙니다.
<a href="https://www.photoshopessentials.com/photo-effects/gradient-map/">포토샵의 그레이디언트 맵</a>과 동일한 효과를 내기 위해 <a href="webgl-post-processing.html">후처리</a>에 램프 텍스처를 사용할 수 있습니다.</p>
<p>GPU 기반의 애니메이션에 램프 텍스처를 사용할 수도 있습니다.
텍스처에 키/값을 저장하고 &quot;시간&quot;을 값으로 사용하여 텍스처로 이동합니다.
이 기술에는 많은 용도가 있습니다.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-ramp-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-ramp-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-ramp-textures.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-ramp-textures.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-ramp-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-ramp-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-ramp-textures.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-ramp-textures.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - 선반 가공</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">색인된 그리기</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 램프 텍스처';
            var disqus_title = 'WebGL 램프 텍스처';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



