<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-planar-projection-mapping.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="텍스처를 평면으로 투영">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg">

<meta property="og:title" content="WebGL 평면 및 원근 투영 매핑">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg">
<meta property="og:description" content="텍스처를 평면으로 투영">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 평면 및 원근 투영 매핑">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">
<meta name="twitter:description" content="텍스처를 평면으로 투영">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html",
      "inLanguage":"ko",
      "name":"WebGL 평면 및 원근 투영 매핑",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 평면 및 원근 투영 매핑</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-planar-projection-mapping.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-planar-projection-mapping.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-planar-projection-mapping.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-planar-projection-mapping.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-planar-projection-mapping.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-planar-projection-mapping.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 평면 및 원근 투영 매핑</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 예제를 정리하기 위해 <a href="webgl-less-code-more-fun.html">유틸리티 함수에 대한 글</a>에서 언급한 라이브러리를 사용합니다.
<code class="notranslate" translate="no">webglUtils.setBuffersAndAttributes</code> 함수가 버퍼와 속성을 설정하는 것이나, <code class="notranslate" translate="no">webglUtils.setUniforms</code> 함수가 유니폼을 설정하는 게 무슨 의미인지 모르겠다면, 뒤로 돌아가서 <a href="webgl-fundamentals.html">WebGL 기초</a>를 먼저 읽어주세요.</p>
<p>또한 <a href="webgl-3d-perspective.html">원근</a>, <a href="webgl-3d-camera.html">카메라</a>, <a href="webgl-3d-textures.html">텍스처</a>, <a href="webgl-visualizing-the-camera.html">카메라 시각화</a>에 대한 글을 읽었다고 가정하기 때문에 읽지 않았다면 먼저 읽어주세요.</p>
<p>투영 매핑은 영사기가 스크린을 향하게 하고 영화를 투사하는 것과 같은 의미로 &quot;투영&quot; 방법입니다.
영사기는 투시면을 투사하는데요.
스크린이 영사기에서 멀어질수록 이미지는 더 커집니다.
영사기에 수직이 아니도록 스크린의 각도를 조정하면 결과는 사디리꼴이나 임의의 사변형이 됩니다.</p>
<div class="webgl_center"><img src="../resources/perspective-projection.svg" style="width: 400px"></div>

<p>물론 투영 매핑이 평평할 필요는 없습니다.
원통형 투영 매핑, 구형 투영 매핑 등이 있죠.</p>
<p>먼저 평면 투영 매핑을 살펴봅시다.
이 경우 스크린이 영사기에서 멀어질수록 영상이 커지는 대신에 동일한 크기가 되도록 영사기가 스크린만큼 크다고 상상해야 합니다.</p>
<div class="webgl_center"><img src="../resources/orthographic-projection.svg" style="width: 400px"></div>

<p>먼저 평면과 구체를 그리는 간단한 장면을 만들어 보겠습니다.
양쪽 모두 간단한 8x8 체커 보드 텍스처를 사용할 겁니다.</p>
<p>셰이더는 다양한 행렬이 분리되어 있으므로 자바스크립트에서 함께 곱할 필요가 없다는 걸 제외하면 <a href="webgl-3d-textures.html">텍스처에 대한 글</a>의 셰이더와 유사합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">// 정점 셰이더
attribute vec4 a_position;
attribute vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

varying vec2 v_texcoord;

void main() {
  gl_Position = u_projection * u_view * u_world * a_position;

  // 프래그먼트 셰이더로 텍스처 좌표 전달
  v_texcoord = a_texcoord;
}
</code></pre>
<p>또한 유니폼 <code class="notranslate" translate="no">u_colorMult</code>를 추가하여 텍스처 색상을 곱했습니다.
단색 텍스처를 만들면 이런 식으로 색상을 변경할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">// 프래그먼트 셰이더
precision mediump float;

// 정점 셰이더에서 전달됩니다.
varying vec2 v_texcoord;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;

void main() {
  gl_FragColor = texture2D(u_texture, v_texcoord) * u_colorMult;
}
</code></pre>
<p>다음은 프로그램, 구체 버퍼, 평면 버퍼를 설정하는 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL 프로그램 설정
// 셰이더 컴파일, 프로그램 연결, 위치 탐색
const textureProgramInfo = webglUtils.createProgramInfo(gl, [&#39;vertex-shader-3d&#39;, &#39;fragment-shader-3d&#39;]);

const sphereBufferInfo = primitives.createSphereBufferInfo(
    gl,
    1,  // 반지름
    12, // 둘레 세분화
    6,  // 수직 세분화
);
const planeBufferInfo = primitives.createPlaneBufferInfo(
    gl,
    20,  // 너비
    20,  // 높이
    1,   // 수평 세분화
    1,   // 수직 세분화
);
</code></pre>
<p>그리고 <a href="webgl-data-textures.html">데이터 텍스처에 관한 글</a>에서 다룬 기술을 사용하여 8x8 픽셀 체커 보드 텍스처를 만드는 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 8x8 체커 보드 텍스처 만들기
const checkerboardTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,                // 밉 레벨
    gl.LUMINANCE,     // 내부 포맷
    8,                // 너비
    8,                // 높이
    0,                // 테두리
    gl.LUMINANCE,     // 포맷
    gl.UNSIGNED_BYTE, // 타입
    new Uint8Array([  // 데이터
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
    ]));
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>그리기 위해 투영 행렬와 카메라 행렬을 가져와서, 카메라 행렬로 뷰 행렬을 계산한 다음, 구체와 큐브를 그리는 함수를 만들겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// 각 객체에 대한 유니폼
const planeUniforms = {
  u_colorMult: [0.5, 0.5, 1, 1],  // 하늘색
  u_texture: checkerboardTexture,
  u_world: m4.translation(0, 0, 0),
};
const sphereUniforms = {
  u_colorMult: [1, 0.5, 0.5, 1],  // 분홍색
  u_texture: checkerboardTexture,
  u_world: m4.translation(2, 3, 4),
};

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(textureProgramInfo.program);

  // 구체와 평면이 공유하는 유니폼 설정
  webglUtils.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
  });

  // ------ 구체 그리기 --------

  // 필요한 모든 속성 설정
  webglUtils.setBuffersAndAttributes(gl, textureProgramInfo, sphereBufferInfo);

  // 구체에 고유한 유니폼 설정
  webglUtils.setUniforms(textureProgramInfo, sphereUniforms);

  // gl.drawArrays 혹은 gl.drawElements 호출
  webglUtils.drawBufferInfo(gl, sphereBufferInfo);

  // ------ 평면 그리기 --------

  // 필요한 모든 속성 설정
  webglUtils.setBuffersAndAttributes(gl, textureProgramInfo, planeBufferInfo);

  // 평면에 고유한 유니폼 설정
  webglUtils.setUniforms(textureProgramInfo, planeUniforms);

  // gl.drawArrays 혹은 gl.drawElements 호출
  webglUtils.drawBufferInfo(gl, planeBufferInfo);
}
</code></pre>
<p>우리는 이 코드는 <code class="notranslate" translate="no">render</code> 함수에서 이렇게 사용할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
};
const fieldOfViewRadians = degToRad(60);

function render() {
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // 클립 공간에서 픽셀로 변환하는 방법을 WebGL에 지시
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  // 캔버스와 깊이 버퍼 지우기
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // 투영 행렬 계산
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

  // lookAt을 사용하여 카메라 행렬 계산
  const cameraPosition = [settings.cameraX, settings.cameraY, 7];
  const target = [0, 0, 0];
  const up = [0, 1, 0];
  const cameraMatrix = m4.lookAt(cameraPosition, target, up);

  drawScene(projectionMatrix, cameraMatrix);
}
render();
</code></pre>
<p>이제 평면과 구체가 있는 간단한 장면이 생겼습니다.
장면 이해를 돕기 위해 카메라 위치를 변경해주는 슬라이더를 추가했습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-setup.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-setup.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>이제 구체와 평면에 텍스처를 평면으로 투영해봅시다.</p>
<p>먼저 <a href="webgl-3d-textures.html">텍스처를 로드</a>합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function loadImageTexture(url) {
  // 텍스처 생성
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // 1x1 파란 픽셀로 텍스처 채우기
  gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1,
    1,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([0, 0, 255, 255])
  );
  // 비동기적으로 이미지 로드
  const image = new Image();
  image.src = url;
  image.addEventListener(&#39;load&#39;, function() {
    // 이제 이미지가 로드되었기 때문에 텍스처로 복사
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
    // 텍스처가 2의 거듭제곱이라 가정
    gl.generateMipmap(gl.TEXTURE_2D);
    render();
  });
  return texture;
}

const imageTexture = loadImageTexture(&#39;resources/f-texture.png&#39;);
</code></pre>
<p><a href="webgl-visualizing-the-camera.html">카메라 시각화에 대한 글</a>을 떠올려보면, -1에서 +1사이의 큐브를 만들고 카메라의 절두체를 나타내도록 그렸습니다.
절두체 내부의 공간이 월드 공간에서 -1에서 +1사이의 클립 공간으로 변환되는 월드 공간 내부에 있는 절두체 모양의 영역을 나타내도록 행렬을 만들었는데요.
여기서도 비슷하게 할 수 있습니다.</p>
<p>한 번 해봅시다.
먼저 프래그먼트 셰이더에서 텍스처 좌표가 0.0에서 1.0사이인 곳에 투영된 텍스처를 그립니다.
해당 범위 밖에서는 체커 보드 텍스처를 사용할 겁니다. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

// 정점 셰이더에서 전달됩니다.
varying vec2 v_texcoord;
+varying vec4 v_projectedTexcoord;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
+uniform sampler2D u_projectedTexture;

void main() {
-  gl_FragColor = texture2D(u_texture, v_texcoord) * u_colorMult;
+  // 올바른 값을 얻기 위해 w로 나누기 (원근에 대한 글 참고)
+  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
+
+  bool inRange = 
+      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
+      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
+      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
+      projectedTexcoord.y &lt;= 1.0;
+
+  vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
+  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
+
+  float projectedAmount = inRange ? 1.0 : 0.0;
+  gl_FragColor = mix(texColor, projectedTexColor, projectedAmount);
}
</code></pre>
<p>투영된 텍스처 좌표를 계산하기 위해 <a href="webgl-visualizing-the-camera.html">카메라 시각화</a>에 대한 글의 특정 방향을 향하도록 배치된 카메라처럼 3D 공간을 나타내는 행렬을 만듭니다.
그런 다음 해당 공간을 통해 구체의 월드 위치와 평면 정점을 투영합니다.
0과 1사이에 있을 때 방금 작성한 코드가 텍스처를 표시할 겁니다.</p>
<p>이 <em>공간</em>을 통해 구체의 월드 위치와 평면 정점을 투영하기 위해 정점 셰이더에 코드를 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">attribute vec4 a_position;
attribute vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
+uniform mat4 u_textureMatrix;

varying vec2 v_texcoord;
+varying vec4 v_projectedTexcoord;

void main() {
+  vec4 worldPosition = u_world * a_position;

-  gl_Position = u_projection * u_view * u_world * a_position;
+  gl_Position = u_projection * u_view * worldPosition;

  // 프래그먼트 셰이더로 텍스처 좌표 전달
  v_texcoord = a_texcoord;

+  v_projectedTexcoord = u_textureMatrix * worldPosition;
}
</code></pre>
<p>이제 남은 것은 이 상대적인 공간을 정의하는 행렬을 실제로 계산하는 겁니다.
다른 객체들과 마찬가지로 월드 행렬을 계산한 다음 역행렬을 적용하면 되는데요.
이는 이 공간에 상대적인 다른 객체들의 월드 위치를 향하는 행렬을 제공할 겁니다.
이건 <a href="webgl-3d-camera.html">카메라에 대한 글</a>에서 사용한 뷰 행렬과 완전히 동일합니다.</p>
<p>마찬가지로 <a href="webgl-3d-camera.html">같은 글</a>에서 만들었던 <code class="notranslate" translate="no">lookAt</code> 함수를 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
+  posX: 3.5,
+  posY: 4.4,
+  posZ: 4.7,
+  targetX: 0.8,
+  targetY: 0,
+  targetZ: 4.7,
};

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // 위치
      [settings.targetX, settings.targetY, settings.targetZ], // 대상
      [0, 1, 0],                                              // 위쪽
  );

  // 이 월드 행렬의 역행렬을 사용하여 다른 위치가 월드 공간에 상대적으로 되도록 변환하는 행렬을 만듭니다.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  // 구체와 평면 모두에 동일한 유니폼 설정
  webglUtils.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
+    u_textureMatrix: textureMatrix,
+    u_projectedTexture: imageTexture,
  });

  ...
}
</code></pre>
<p>물론 꼭 <code class="notranslate" translate="no">lookAt</code>을 사용하지 않아도 됩니다.
예를 들어 <a href="webgl-scene-graph.html">장면 그래프</a>나 <a href="webgl-2d-matrix-stack.html">행렬 스택</a>을 사용하여 원하는대로 월드 행렬을 만들 수 있습니다.</p>
<p>실행 전에 몇 가지 스케일을 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 3.5,
  posY: 4.4,
  posZ: 4.7,
  targetX: 0.8,
  targetY: 0,
  targetZ: 4.7,
+  projWidth: 2,
+  projHeight: 2,
};

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // 위치
      [settings.targetX, settings.targetY, settings.targetZ], // 대상
      [0, 1, 0],                                              // 위쪽
  );
+  textureWorldMatrix = m4.scale(
+      textureWorldMatrix,
+      settings.projWidth, settings.projHeight, 1,
+  );

  // 이 월드 행렬의 역행렬을 사용하여 다른 위치가 월드 공간에 상대적으로 되도록 변환하는 행렬을 만듭니다.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  ...
}
</code></pre>
<p>이를 통해 투영된 텍스처를 얻습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>텍스처가 들어있는 공간을 보기 힘들 수도 있을 것 같습니다.
시각화를 돕기 위해 wireframe cube를 추가해봅시다.</p>
<p>먼저 별도의 셰이더 세트가 필요합니다.
이 셰이더는 텍스처 없이, 단색만 그릴 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;script id=&quot;color-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
attribute vec4 a_position;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

void main() {
  // 위치에 행렬 곱하기
  gl_Position = u_projection * u_view * u_world * a_position;
}
&lt;/script&gt;
</code></pre>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;script id=&quot;color-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;

uniform vec4 u_color;
void main() {
  gl_FragColor = u_color;
}
&lt;/script&gt;
</code></pre>
<p>그런 다음 이 셰이더도 컴파일하고 연결해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL 프로그램 설정
const textureProgramInfo = webglUtils.createProgramInfo(gl, [&#39;vertex-shader-3d&#39;, &#39;fragment-shader-3d&#39;]);
+const colorProgramInfo = webglUtils.createProgramInfo(gl, [&#39;color-vertex-shader&#39;, &#39;color-fragment-shader&#39;]);
</code></pre>
<p>그리고 선으로 만들어진 큐브를 그리기 위한 데이터가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sphereBufferInfo = primitives.createSphereBufferInfo(
    gl,
    1,  // 반지름
    12, // 둘레 세분화
    6,  // 수직 세분화
);
const planeBufferInfo = primitives.createPlaneBufferInfo(
    gl,
    20,  // 너비
    20,  // 높이
    1,   // 수평 세분화
    1,   // 수직 세분화
);
+const cubeLinesBufferInfo = webglUtils.createBufferInfoFromArrays(gl, {
+  position: [
+     0,  0, -1,
+     1,  0, -1,
+     0,  1, -1,
+     1,  1, -1,
+     0,  0,  1,
+     1,  0,  1,
+     0,  1,  1,
+     1,  1,  1,
+  ],
+  indices: [
+    0, 1,
+    1, 3,
+    3, 2,
+    2, 0,
+
+    4, 5,
+    5, 7,
+    7, 6,
+    6, 4,
+
+    0, 4,
+    1, 5,
+    3, 7,
+    2, 6,
+  ],
+});
</code></pre>
<p>이 큐브는 텍스처 좌표를 맞추기 위해 X와 Y에 대해 0에서 1사이가 됩니다.
Z의 경우 -1에서 1사이가 되죠.
이건 양쪽 방향으로 늘릴 수 있도록 크기를 조정하기 위한 겁니다.</p>
<p>이제 그걸 써서 하고 싶은 것은 공간이 존재하는 곳에 큐브를 그리는 것이기 때문에 이전의 <code class="notranslate" translate="no">textureWorldMatrix</code>를 사용할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(projectionMatrix, cameraMatrix) {

  ...
+  // ------ 큐브 그리기 ------
+
+  gl.useProgram(colorProgramInfo.program);
+
+  // 필요한 모든 속성 설정
+  webglUtils.setBuffersAndAttributes(gl, colorProgramInfo, cubeLinesBufferInfo);
+
+  // Z에서 큐브의 크기를 조정하기 때문에 무한대로 투영되는 텍스처를 나타내기 위해 정말 길어집니다.
+  const mat = m4.scale(textureWorldMatrix, 1, 1, 1000);
+
+  // 계산한 유니폼 설정
+  webglUtils.setUniforms(colorProgramInfo, {
+    u_color: [0, 0, 0, 1],
+    u_view: viewMatrix,
+    u_projection: projectionMatrix,
+    u_world: mat,
+  });
+
+  // gl.drawArrays 혹은 gl.drawElements 호출
+  webglUtils.drawBufferInfo(gl, cubeLinesBufferInfo, gl.LINES);
}
</code></pre>
<p>이제 projection이 어디있는지 더 쉽게 알 수 있습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-lines.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-lines.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>정말로 텍스처를 <em>투영</em>한 것이 아니라는 점을 유의해야 합니다.
오히려 정반대입니다.
렌더링되는 객체의 각 픽셀에 대해 텍스처의 어느 부분이 거기에 투영되는지 확인한 다음 텍스처의 해당 부분에서 색상을 찾습니다.</p>
<p>위의 영사기를 언급했는데 어떻게 영사기를 시뮬레이션할까요?
기본적으로는 투영 행렬로 곱할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 2.5,
  posY: 4.8,
  posZ: 4.3,
  targetX: 2.5,
  targetY: 0,
  targetZ: 3.5,
  projWidth: 1,
  projHeight: 1,
+  perspective: true,
+  fieldOfView: 45,
};

...

function drawScene(projectionMatrix, cameraMatrix) {
  // 카메라 행렬로 뷰 행렬 만들기
  const viewMatrix = m4.inverse(cameraMatrix);

  const textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // 위치
      [settings.targetX, settings.targetY, settings.targetZ], // 대상
      [0, 1, 0],                                              // 위쪽
  );
-  textureWorldMatrix = m4.scale(
-      textureWorldMatrix,
-      settings.projWidth, settings.projHeight, 1,
-  );

+  const textureProjectionMatrix = settings.perspective
+      ? m4.perspective(
+          degToRad(settings.fieldOfView),
+          settings.projWidth / settings.projHeight,
+          0.1,  // 근거리
+          200)  // 원거리
+      : m4.orthographic(
+          -settings.projWidth / 2,   // 왼쪽
+           settings.projWidth / 2,   // 오른쪽
+          -settings.projHeight / 2,  // 아래쪽
+           settings.projHeight / 2,  // 위쪽
+           0.1,                      // 근거리
+           200);                     // 원거리

  // 이 월드 행렬의 역행렬을 사용하여 다른 위치가 월드 공간에 상대적으로 되도록 변환하는 행렬을 만듭니다.
-  const textureMatrix = m4.inverse(textureWorldMatrix);
+  const textureMatrix = m4.multiply(
+      textureProjectionMatrix,
+      m4.inverse(textureWorldMatrix));
</code></pre>
<p>참고로 원근이나 직교 투영 행렬을 사용하는 선택지가 있습니다.</p>
<p>또한 선을 그릴 때 해당 투영 행렬을 사용해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// ------ 큐브 그리기 ------

...

-// Z에서 큐브의 크기를 조정하기 때문에 무한대로 투영되는 텍스처를 나타내기 위해 정말 길어집니다.
-const mat = m4.scale(textureWorldMatrix, 1, 1, 1000);

+// 투영과 일치하도록 큐브 방향 조정
+const mat = m4.multiply(
+    textureWorldMatrix, m4.inverse(textureProjectionMatrix));
</code></pre>
<p>이러면 다음과 같은 결과를 얻습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-projection-matrix-0-to-1.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-projection-matrix-0-to-1.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>작동은 하지만 투영과 큐브 라인은 모두 0에서 1사이의 공간을 사용하므로 투영 절두체의 1/4만 사용합니다.</p>
<p>수정을 위해 먼저 큐브를 모든 방향으로 -1에서 +1사이인 큐브로 만들어봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const cubeLinesBufferInfo = webglUtils.createBufferInfoFromArrays(gl, {
  position: [
-     0,  0, -1,
-     1,  0, -1,
-     0,  1, -1,
-     1,  1, -1,
-     0,  0,  1,
-     1,  0,  1,
-     0,  1,  1,
-     1,  1,  1,
+    -1, -1, -1,
+     1, -1, -1,
+    -1,  1, -1,
+     1,  1, -1,
+    -1, -1,  1,
+     1, -1,  1,
+    -1,  1,  1,
+     1,  1,  1,
  ],
  indices: [
    0, 1,
    1, 3,
    3, 2,
    2, 0,

    4, 5,
    5, 7,
    7, 6,
    6, 4,

    0, 4,
    1, 5,
    3, 7,
    2, 6,
  ],
});
</code></pre>
<p>그런 다음 텍스처 행렬을 사용할 때 절두체 내부 공간을 0에서 1사이로 만들어야 하는데, 공간을 0.5만큼 오프셋하고 0.5로 스케일링하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const textureWorldMatrix = m4.lookAt(
    [settings.posX, settings.posY, settings.posZ],          // 위치
    [settings.targetX, settings.targetY, settings.targetZ], // 대상
    [0, 1, 0],                                              // 위쪽
);
const textureProjectionMatrix = settings.perspective
    ? m4.perspective(
        degToRad(settings.fieldOfView),
        settings.projWidth / settings.projHeight,
        0.1,  // 근거리
        200)  // 원거리
    : m4.orthographic(
        -settings.projWidth / 2,   // 왼쪽
         settings.projWidth / 2,   // 오른쪽
        -settings.projHeight / 2,  // 아래쪽
         settings.projHeight / 2,  // 위쪽
         0.1,                      // 근거리
         200);                     // 원거리

-// 이 월드 행렬의 역행렬을 사용하여 다른 위치가 월드 공간에 상대적으로 되도록 변환하는 행렬을 만듭니다.
-const textureMatrix = m4.multiply(
-    textureProjectionMatrix,
-    m4.inverse(textureWorldMatrix));

+let textureMatrix = m4.identity();
+textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
+textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);
+textureMatrix = m4.multiply(textureMatrix, textureProjectionMatrix);
+// 이 월드 행렬의 역행렬을 사용하여 다른 위치가 월드 공간에 상대적으로 되도록 변환하는 행렬을 만듭니다.
+textureMatrix = m4.multiply(
+    textureMatrix,
+    m4.inverse(textureWorldMatrix));
</code></pre>
<p>이제 작동하는 것 같네요.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-projection-matrix.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-projection-matrix.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>그래서 텍스처를 평면으로 투영하는 것의 장점이 뭘까요?</p>
<p>하나는 여러분이 원하기 때문이죠, 하하.
대부분의 3D 모델링 패키지는 텍스처를 평면으로 투영하는 기능을 제공합니다.</p>
<p>또 하나는 데칼입니다.
데칼은 표면에 페인트 얼룩이나 폭발 흔적을 붙이는 방법입니다.
일반적으로 데칼은 위와 같은 셰이더를 통해 작동하지 않습니다.
대신에 데칼을 적용하려는 모델의 지오메트리를 검토하는 함수를 작성하는데요.
자바스크립트의 셰이더 예제에 있는 <code class="notranslate" translate="no">inRange</code> 확인과 동일하게, 각 삼각형에 대해 데칼이 적용될 영역의 내부에 있는지 확인합니다.
범위 내에 있는 각 삼각형에 대해 투영된 텍스처 좌표를 사용하여 새로운 지오메트리에 추가합니다.
그런 다음 해당 데칼을 그려야 하는 목록에 추가하면 되죠.</p>
<p>지오메트리를 생성은 적절한 방법이며, 그렇지 않으면 2개, 3개, 4개의 다른 셰이더가 필요하고 너무 복잡해져서 GPU 셰이더 텍스처 제한에 도달하게 됩니다.</p>
<p>또 다른 것은 현실 세계의 <a href="https://en.wikipedia.org/wiki/Projection_mapping">투영 매핑</a>을 시뮬레이션하는 겁니다.
영상을 투사할 3D 모델을 만든 다음 영상을 텍스처로 사용하는 것을 제외하고는 위와 같은 코드를 사용하여 투사합니다.
그러면 영사기와 함께 실제 현장에 있을 필요없이 모델에 맞춰 영상을 완성하고 편집할 수 있습니다.</p>
<p>이런 종류의 투영이 유용한 다른 것은 <a href="webgl-shadows.html">그림자 매핑을 이용한 그림자 계산</a>입니다.</p>
<div class="webgl_bottombar">
<h3>조건부 텍스처 참조</h3>
<p>위의 프래그먼트 셰이더에서 모든 경우에 두 가지 텍스처를 읽게 됩니다.</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;

  float projectedAmount = inRange ? 1.0 : 0.0;
  gl_FragColor = mix(texColor, projectedTexColor, projectedAmount);
</code></pre>
<p>왜 이렇게 하지 않았을까요?</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  if (inRange) {
    gl_FragColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
  } else {
    gl_FragColor = texture2D(u_texture, v_texcoord) * u_colorMult;
  }
</code></pre>
<p><a href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL ES 1.0 스펙 부록 A, 섹션 6</a>을 보면</p>
<blockquote>
<h4>텍스처 접근</h4>
<p>
유니폼이 아닌 조건부 블록의 바디 내에서 밉 매핑된 텍스처에 접근하면 정의되지 않은 값이 제공됩니다.
유니폼이 아닌 조건부 블록은 컴파일 시 실행을 결정할 수 없는 블록입니다.
<p>
</blockquote>
<p>
다시 말해 밉 매핑된 텍스처를 사용하려면 항상 접근해야 하는데요.
결과를 조건부로 사용할 수 있습니다.
예를 들어 다음과 같이 작성할 수 있죠.
</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;

  if (inRange) {
    gl_FragColor = projectedTexColor;
  } else {
    gl_FragColor = texColor;
  }
</code></pre>
<p>혹은 이렇게</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
  vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;

  gl_FragColor = inRange ? projectedTexColor : texColor;
</code></pre>
<p>
하지만 밉 매핑 텍스처 자체에 조건부로 접근할 수는 없는데요.
GPU에서 작동하지만 모든 GPU에서 작동하지는 않습니다.
밉 매핑되지 않은 텍스처에 대해서는 아무 명령도 내리지 않으므로 밉 매핑 텍스처가 아닌 것을 알고 있다면 괜찮습니다.
</p>
<p>어쨌든 아는 것이 중요합니다.</p>
<p>
<code class="notranslate" translate="no">inRange</code>를 기반으로 분리하는 대신 <code class="notranslate" translate="no">mix</code>를 사용하는 이유는 개인적인 취향입니다.
<code class="notranslate" translate="no">mix</code>가 더 유연하기 때문에 보통 이걸로 작성합니다.
</p>
</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-planar-projection-mapping.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-planar-projection-mapping.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-planar-projection-mapping.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-planar-projection-mapping.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-planar-projection-mapping.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-planar-projection-mapping.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - 선반 가공</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">색인된 그리기</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 평면 및 원근 투영 매핑';
            var disqus_title = 'WebGL 평면 및 원근 투영 매핑';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



