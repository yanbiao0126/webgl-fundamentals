<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-drawing-without-data.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="창의적 코딩 - 데이터 없이 그리기">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_ko.jpg">

<meta property="og:title" content="WebGL 데이터 없이 그리기">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_ko.jpg">
<meta property="og:description" content="창의적 코딩 - 데이터 없이 그리기">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 데이터 없이 그리기">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html">
<meta name="twitter:description" content="창의적 코딩 - 데이터 없이 그리기">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-drawing-without-data_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html",
      "inLanguage":"ko",
      "name":"WebGL 데이터 없이 그리기",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 데이터 없이 그리기</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="uk" href="https://webglfundamentals.org/webgl/lessons/uk/webgl-drawing-without-data.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-drawing-without-data.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-drawing-without-data.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-drawing-without-data.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-drawing-without-data.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-drawing-without-data.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-drawing-without-data.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-without-data.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-drawing-without-data.html" >Русский</a>
    <option value="/webgl/lessons/uk/webgl-drawing-without-data.html" >Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-without-data.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 데이터 없이 그리기</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 <a href="webgl-fundamentals.html">기초</a>로 시작한 다른 글을 이미 읽었다고 가정합니다.
아직 읽지 않았다면 거기부터 시작해주세요.</p>
<p><a href="webgl-smallest-programs.html">최소 WebGL 프로그램에 대한 글</a>에서 굉장히 적은 코드로 그리는 예제를 다뤘는데요.
이 글에서는 데이터 없이 그려볼 겁니다.</p>
<p>관례적으로 WebGL 앱은 지오메트리 데이터를 버퍼에 넣습니다.
그런 다음 속성을 사용하여 버퍼에서 정점 데이터를 셰이더로 가져와 클립 공간으로 변환하는데요.</p>
<p><strong>관례적</strong>이라는 점이 중요합니다.
이런 식으로 하는 것은 <strong>관례</strong>일 뿐입니다.
이는 결코 요구 사항이 아닙니다.
우리가 어떻게 하던지 WebGL은 상관하지 않고, 정점 셰이더가 클립 공간 좌표를 <code class="notranslate" translate="no">gl_Position</code>에 할당하는 것만 신경씁니다.</p>
<p>그러니 위치 대신 개수만 속성에 제공해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const numVerts = 20;
const vertexIds = new Float32Array(numVerts);
vertexIds.forEach((v, i) =&gt; {
  vertexIds[i] = i;
});

const idBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexIds, gl.STATIC_DRAW);
</code></pre>
<p>이제 그 개수만큼의 점으로 원을 그리는 정점 셰이더를 만듭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;

#define PI radians(180.0)

void main() {
  float u = vertexId / numVerts;      // 0 ~ 1
  float angle = u * PI * 2.0;         // 0 ~ 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

  gl_Position = vec4(pos, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>위 코드는 아주 복잡하지 않아야 합니다.
<code class="notranslate" translate="no">vertexId</code>은 0에서 <code class="notranslate" translate="no">numVerts</code>까지 세어지는데요.
이를 기반으로 원의 위치를 생성합니다.</p>
<p>거기서 멈춘다면 클립 공간이 캔버스의 상하좌우로 정규화(-1 ~ 1)되기 때문에 원은 타원일 겁니다.
하지만 해상도를 전달하여 캔버스의 가로 -1부터 1까지가 세로 -1부터 1까지와 동일한 공간을 나타내지 않도록 할 수 있는데요.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;
+uniform vec2 resolution;

#define PI radians(180.0)

void main() {
  float u = vertexId / numVerts;      // 0 ~ 1
  float angle = u * PI * 2.0;         // 0 ~ 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

+  float aspect = resolution.y / resolution.x;
+  vec2 scale = vec2(aspect, 1);

+  gl_Position = vec4(pos * scale, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>그리고 프래그먼트 셰이더는 단색을 그리기만 하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

void main() {
  gl_FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>초기화할 때 자바스크립트에서 셰이더를 컴파일하고 속성과 유니폼을 찾고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL 프로그램 설정
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const vertexIdLoc = gl.getAttribLocation(program, &#39;vertexId&#39;);
const numVertsLoc = gl.getUniformLocation(program, &#39;numVerts&#39;);
const resolutionLoc = gl.getUniformLocation(program, &#39;resolution&#39;);
</code></pre>
<p>렌더링을 위해 프로그램을 사용하고, vertexId로 속성을 설정하며, <code class="notranslate" translate="no">resolution</code> 그리고 <code class="notranslate" translate="no">numVerts</code> 유니폼을 설정한 다음, 마지막으로 점을 그립니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

{
  // 속성 활성화
  gl.enableVertexAttribArray(vertexIdLoc);

  // idBuffer 할당
  gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);

  // idBuffer(ARRAY_BUFFER)에서 데이터 가져오는 방법을 속성에 지시
  const size = 1;          // 반복마다 1개의 컴포넌트
  const type = gl.FLOAT;   // 데이터는 32비트 부동 소수점
  const normalize = false; // 데이터 정규화 안 함
  const stride = 0;        // 0 = 다음 위치를 가져오기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동 
  const offset = 0;        // 버퍼의 처음부터 시작
  gl.vertexAttribPointer(vertexIdLoc, size, type, normalize, stride, offset);
}

// 셰이더에게 정점의 개수를 알림
gl.uniform1f(numVertsLoc, numVerts);
// 셰이더에게 해상도를 알림
gl.uniform2f(resolutionLoc, gl.canvas.width, gl.canvas.height);

const offset = 0;
gl.drawArrays(gl.POINTS, offset, numVerts);
</code></pre>
<p>그리고 점으로 그려진 원을 얻습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-circle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-circle.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>이 기술이 유용할까요?
몇 가지 창의적인 코드를 사용해 거의 데이터 없이 단일 그리기 호출로 스타필드나 간단한 비 효과를 만들 수 있습니다.</p>
<p>작동하는지 보기 위해 비를 내리게 해봅시다.
먼저 정점 셰이더를 바꿀 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;
uniform float time;

void main() {
  float u = vertexId / numVerts;          // 0 ~ 1
  float x = u * 2.0 - 1.0;                // -1 ~ 1
  float y = fract(time + u) * -2.0 + 1.0; // 1.0 -&gt; -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>이 경우에는 해상도가 필요하지 않습니다.</p>
<p>페이지가 로드된 이후 초 단위의 시간이 되는 유니폼 <code class="notranslate" translate="no">time</code>을 추가했습니다.</p>
<p>&#39;x&#39;의 경우 -1에서 1사이가 됩니다.</p>
<p>&#39;y&#39;의 경우 <code class="notranslate" translate="no">time + u</code>를 사용하지만 <code class="notranslate" translate="no">fract</code>이 소수 부분만 반환하므로 값은 0.0에서 1.0사이가 됩니다.
이를 1.0에서 -1.0사이로 확장하면 시간이 지남에 따라 반복되지만 각 점에 대해 다르게 오프셋되는 y를 얻습니다.</p>
<p>프래그먼트 셰이더에서 색상을 파란색으로 바꿔봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">precision mediump float;

void main() {
-  gl_FragColor = vec4(1, 0, 0, 1);
+  gl_FragColor = vec4(0, 0, 1, 1);
}
</code></pre>
<p>그런 다음 자바스크립트에서 유니폼 <code class="notranslate" translate="no">time</code>을 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// GLSL 프로그램 설정
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const vertexIdLoc = gl.getAttribLocation(program, &#39;vertexId&#39;);
const numVertsLoc = gl.getUniformLocation(program, &#39;numVerts&#39;);
-const resolutionLoc = gl.getUniformLocation(program, &#39;resolution&#39;);
+const timeLoc = gl.getUniformLocation(program, &#39;time&#39;);
</code></pre>
<p>그리고 렌더링 루프를 만들고 유니폼 <code class="notranslate" translate="no">time</code>을 설정하여 <a href="webgl-animation.html">애니메이션</a>되는 코드로 변환해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+function render(time) {
+  time *= 0.001;  // 초 단위로 변환

+  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(program);

  {
    // 속성 활성화
    gl.enableVertexAttribArray(vertexIdLoc);

    // idBuffer 할당
    gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);

    // idBuffer(ARRAY_BUFFER)에서 데이터 가져오는 방법을 속성에 지시
    const size = 1;          // 반복마다 1개의 컴포넌트
    const type = gl.FLOAT;   // 데이터는 32비트 부동 소수점
    const normalize = false; // 데이터 정규화 안 함
    const stride = 0;        // 0 = 다음 위치를 가져오기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동
    const offset = 0;        // 버퍼의 처음부터 시작
    gl.vertexAttribPointer(vertexIdLoc, size, type, normalize, stride, offset);
  }

  // 셰이더에 정점의 개수를 알림
  gl.uniform1f(numVertsLoc, numVerts);
+  // 셰이더에 시간을 알림
+  gl.uniform1f(timeLoc, time);

  const offset = 0;
  gl.drawArrays(gl.POINTS, offset, numVerts);

+  requestAnimationFrame(render);
+}
+requestAnimationFrame(render);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain-linear.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>점들이 화면 아래로 내려가긴 하지만 모두 순서대로 내려갑니다.
약간의 무작위성을 추가해야 하는데요.
GLSL에는 랜덤 숫자 생성기가 없습니다.
대신에 충분히 랜덤으로 보이도록 생성하는 함수를 사용할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">// https://www.shadertoy.com/view/4djSRW
// 위의 해시 함수는 0에서 1사이의 값이 주어졌을 때 무작위로 나타나는 0과 1사이의 값을 반환합니다.
float hash(float p) {
  vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));
  p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));
  return fract(p2.x * p2.y * 95.4337);
}
</code></pre>
<p>그리고 이렇게 사용할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
  float u = vertexId / numVerts;          // 0 ~ 1
-  float x = u * 2.0 - 1.0;                // -1 ~ 1
+  float x = hash(u) * 2.0 - 1.0;          // 랜덤 위치
  float y = fract(time + u) * -2.0 + 1.0; // 1.0 -&gt; -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 5.0;
}
</code></pre>
<p>이전의 0과 1사이 값을 <code class="notranslate" translate="no">hash</code>에 전달하고 이는 0과 1사이의 유사 랜덤 값을 반환합니다.</p>
<p>점도 저 작게 만들어봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">  gl_Position = vec4(x, y, 0, 1);
-  gl_PointSize = 5.0;
+  gl_PointSize = 2.0;
</code></pre>
<p>그리고 그리는 점의 개수를 늘립니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const numVerts = 20;
+const numVerts = 400;
</code></pre>
<p>그러면 다음과 같은 결과를 얻습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>자세히 보면 일정 패턴의 비가 반복되는 것을 볼 수 있습니다.
바닥에 떨어졌다가 다시 위에서 나오게 됩니다.
3D 게임에서의 비 효과처럼 더 많은 일들이 백그라운드에서 일어나면 아무도 반복되는 걸 눈치채지 못할 겁니다.</p>
<p>약간의 무작위성을 더 추가하여 반복을 고칠 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
  float u = vertexId / numVerts;          // 0 ~ 1
+  float off = floor(time + u) / 1000.0;   // 각 정점에 대해 초당 한 번씩 변경
-  float x = hash(u) * 2.0 - 1.0;          // 랜덤 위치
+  float x = hash(u + off) * 2.0 - 1.0;    // 랜덤 위치
  float y = fract(time + u) * -2.0 + 1.0; // 1.0 -&gt; -1.0

  gl_Position = vec4(x, y, 0, 1);
  gl_PointSize = 2.0;
}
</code></pre>
<p>위 코드에서 <code class="notranslate" translate="no">off</code>를 추가했습니다.
<code class="notranslate" translate="no">floor</code>를 호출하기 때문에 <code class="notranslate" translate="no">floor(time + u)</code>의 값은 각 정점에 대해 초당 한 번만 변경되는 초 단위 타이머를 제공합니다.
이 오프셋은 점이 화면 아래로 이동하는 코드와 동기화되기 때문에, 점이 화면의 상단으로 다시 올라가는 동시에 <code class="notranslate" translate="no">hash</code>에 값이 조금 추가되어, 새로운 랜덤 숫자와 이로 인한 새로운 랜덤 수평 위치를 얻게 됩니다.</p>
<p>결과는 반복되지 않는 비 효과입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-point-rain-less-repeat.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-point-rain-less-repeat.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p><code class="notranslate" translate="no">gl.POINTS</code> 이상을 할 수 있을까요?
물론입니다! </p>
<p>원을 만들어봅시다.
이를 위해 파이 조각처럼 중앙 주변의 삼각형이 필요한데요.
각 삼각형을 파이의 가장자리의 점 2개와 중앙에 점 1개가 있다고 생각할 수 있습니다.
파이의 각 조각에 대해 반복하면 다음과 같습니다.</p>
<div class="webgl_center"><img src="../resources/circle-points.svg" style="width: 400px;"></div>

<p>따라서 먼저 파이 조각마다 한 번씩 변경되는 일종의 카운터가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float sliceId = floor(vertexId / 3.0);
</code></pre>
<p>그런 다음 원의 가장자리에 숫자가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">0, 1, ?, 1, 2, ?, 2, 3, ?, ...
</code></pre><p>위 다이어그램을 보면 3번째 값이 항상 중앙(0,0)이여서 값에 관계없이 0으로 곱할 수 있기 때문에 ?는 중요하지 않습니다.</p>
<p>위 패턴을 얻기 위해 이렇게 작업할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float triVertexId = mod(vertexId, 3.0);
float edge = triVertexId + sliceId;
</code></pre>
<p>가장자리의 점과 중앙의 점의 경우 이 패턴이 필요한데, 가장자리의 2개 다음 중앙에 1개를 반복합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">1, 1, 0, 1, 1, 0, 1, 1, 0, ...
</code></pre><p>아래 코드를 이용해 해당 패턴을 얻을 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float radius = step(1.5, triVertexId);
</code></pre>
<p>a &lt; b이면 <code class="notranslate" translate="no">step(a, b)</code>는 0이고 그렇지 않으면 1인데요.
이렇게 생각할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function step(a, b) {
  return a &lt; b ? 0 : 1;
}
</code></pre>
<p><code class="notranslate" translate="no">triVertexId</code>이 1.5보다 크면 <code class="notranslate" translate="no">step(1.5, triVertexId)</code>는 1이 됩니다.
각 삼각형의 처음 정점 2개는 <code class="notranslate" translate="no">true</code>고 마지막 정점은 <code class="notranslate" translate="no">false</code>입니다.</p>
<p>다음과 같이 원에 대한 삼각형의 정점을 얻을 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float numSlices = 8.0;
float sliceId = floor(vertexId / 3.0);
float triVertexId = mod(vertexId, 3.0);
float edge = triVertexId + sliceId;
float angleU = edge / numSlices;  // 0.0 to 1.0
float angle = angleU * PI * 2.0;
float radius = step(triVertexId, 1.5);
vec2 pos = vec2(cos(angle), sin(angle)) * radius;
</code></pre>
<p>이 모든 걸 합쳐서 하나의 원을 그려봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">attribute float vertexId;
uniform float numVerts;
uniform vec2 resolution;

#define PI radians(180.0)

void main() {
  float numSlices = 8.0;
  float sliceId = floor(vertexId / 3.0);
  float triVertexId = mod(vertexId, 3.0);
  float edge = triVertexId + sliceId;
  float angleU = edge / numSlices;  // 0.0 to 1.0
  float angle = angleU * PI * 2.0;
  float radius = step(triVertexId, 1.5);
  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

  float aspect = resolution.y / resolution.x;
  vec2 scale = vec2(aspect, 1);

  gl_Position = vec4(pos * scale, 0, 1);
}
</code></pre>
<p>타원이 되지 않도록 <code class="notranslate" translate="no">resolution</code>을 다시 넣었습니다.</p>
<p>8개의 조각 원은 8 * 3개의 정점이 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const numVerts = 400;
+const numVerts = 8 * 3;
</code></pre>
<p>그리고 <code class="notranslate" translate="no">POINTS</code>가 아니라 <code class="notranslate" translate="no">TRIANGLES</code>를 그려야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const offset = 0;
-gl.drawArrays(gl.POINTS, offset, numVerts);
+gl.drawArrays(gl.TRIANGLES, offset, numVerts);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-triangles-circle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-triangles-circle.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>그리고 여러 개의 원을 그리고 싶다면 어떻게 해야 할까요?</p>
<p>우리가 해야할 일은 모든 정점에 대해 동일한 각 원의 위치 선택에 사용할 수 있는 <code class="notranslate" translate="no">circleId</code>를 찾는 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float numVertsPerCircle = numSlices * 3.0;
float circleId = floor(vertexId / numVertsPerCircle);
</code></pre>
<p>예시로 원으로 구성된 원을 그려봅시다.</p>
<p>먼저 위 코드를 함수로 바꿉니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">vec2 computeCircleTriangleVertex(float vertexId) {
  float numSlices = 8.0;
  float sliceId = floor(vertexId / 3.0);
  float triVertexId = mod(vertexId, 3.0);
  float edge = triVertexId + sliceId;
  float angleU = edge / numSlices;  // 0.0 to 1.0
  float angle = angleU * PI * 2.0;
  float radius = step(triVertexId, 1.5);
  return vec2(cos(angle), sin(angle)) * radius;
}
</code></pre>
<p>다음은 이 글의 맨 위에서 점들의 원을 그리는데 사용한 원래 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">float u = vertexId / numVerts;      // 0 ~ 1
float angle = u * PI * 2.0;         // 0 ~ 2PI
float radius = 0.8;

vec2 pos = vec2(cos(angle), sin(angle)) * radius;

float aspect = resolution.y / resolution.x;
vec2 scale = vec2(aspect, 1);

gl_Position = vec4(pos * scale, 0, 1);
</code></pre>
<p><code class="notranslate" translate="no">vertexId</code> 대신에 <code class="notranslate" translate="no">circleId</code>를 사용하도록 수정하고 정점 수 대신에 원 개수로 나누도록 변경해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
+  float circleId = floor(vertexId / numVertsPerCircle);
+  float numCircles = numVerts / numVertsPerCircle;

-  float u = vertexId / numVerts;      // 0 ~ 1
+  float u = circleId / numCircles;    // 0 ~ 1
  float angle = u * PI * 2.0;         // 0 ~ 2PI
  float radius = 0.8;

  vec2 pos = vec2(cos(angle), sin(angle)) * radius;

+  vec2 triPos = computeCircleTriangleVertex(vertexId) * 0.1;

  float aspect = resolution.y / resolution.x;
  vec2 scale = vec2(aspect, 1);

-  gl_Position = vec4(pos * scale, 0, 1);
+  gl_Position = vec4((pos + triPos) * scale, 0, 1);
}
</code></pre>
<p>그런 다음 정점 수를 늘려야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const numVerts = 8 * 3;
+const numVerts = 8 * 3 * 20;
</code></pre>
<p>그리고 이제 20개의 원으로 구성된 원이 생겼습니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-no-data-triangles-circles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-no-data-triangles-circles.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>물론 원 모양의 비를 만들기 위해 위에서 했던 걸 적용할 수 있습니다.
아마 의미가 없을 것이기 때문에 다루지는 않겠지만 정점 셰이더에서 데이터 없이 삼각형 만드는 방법을 보여줍니다.</p>
<p>위 기술은 직사각형이나 정사각형을 만든 다음, UV 좌표를 생성하고, 프래그먼트 셰이더로 전달하여 생성된 지오메트리를 텍스처 매핑합니다.
이는 <a href="webgl-3d-perspective.html">3D 원근법</a>에 대한 글에서 사용한 3D 기술을 적용하여 뒤집어지는 눈송이와 나뭇잎이 떨어지는 효과에 유용할 수 있습니다.</p>
<p><strong>이러한 기술</strong>이 일반적이지 않다는 점을 강조하고 싶습니다.
간단한 파티클 시스템을 만드는 것은 반쯤 일반적이거나 위의 비 효과일 수 있지만 엄청나게 복잡한 계산을 하면 성능이 저하됩니다.
일반적으로 성능을 원한다면 컴퓨터에 가능한 작은 작업 단위로 요청해야 하므로, 초기화할 때 미리 계산하고 어떤 형태로든 셰이더에 전달할 수 있도록 해야 합니다.</p>
<p>예를 들어 여기 여러 큐브를 계산하는 극단적인 정점 셰이더가 있습니다. (경고, 소리 있음)</p>
<iframe width="700" height="400" src="https://www.vertexshaderart.com/art/zd2E5vCZduc5JeoFz" frameborder="0" allowfullscreen></iframe>

<p>퍼즐에 대한 지적 호기심으로 &quot;Vertex ID 외에는 데이터가 없다면 흥미로운 걸 그릴 수 있을까요?&quot; 이에 대한 대답은 꽤 깔끔합니다.
사실 <a href="https://www.vertexshaderart.com">해당 웹사이트 전체</a>가 vertex id만 있을 때 흥미로운 걸 만들 수 있을까 하는 퍼즐에 관한 겁니다.
하지만 성능을 위해 큐브 정점 데이터를 버퍼에 전달하고 해당 데이터를 속성이나 다른 글에서 다룰 기술로 읽어들이는 기존의 방법을 사용하는 게 훨씬 빠릅니다.</p>
<p>어느 정도 균형을 잡아야 합니다.
위의 비가 내리는 예시에서 정확한 효과를 원한다면 위의 코드는 굉장히 효율적입니다.
둘 사이 어딘가에는 한 기술이 다른 기술보다 성능이 좋은 경계가 있습니다.
일반적으로는 기존의 기술들이 훨씬 유연하지만 어떤 방법을 사용할 지 경우에 따라 결정해야 합니다.</p>
<p>이 글의 요점은 대개 이러한 아이디어를 소개하고 WebGL이 실제로 하는 일에 대한 다른 사고 방식을 강조하는 겁니다.
다시 말하지만 셰이더에서 <code class="notranslate" translate="no">gl_Position</code>과 <code class="notranslate" translate="no">gl_FragColor</code>를 설정하는 것만 신경쓰면 됩니다.
그 외에는 어떻게 하든 상관없습니다.</p>
<p>다음은 <a href="webgl-shadertoy.html">Shadertoy 셰이더의 작동 방식</a>을 다뤄보겠습니다.</p>
<div class="webgl_bottombar" id="pointsissues">
<h3><code class="notranslate" translate="no">gl.POINTS</code> 문제</h3>
<p>이와 같은 기술로 할 수 있는 유용한 한 가지는 <code class="notranslate" translate="no">gl.POINTS</code>로 그리기를 시뮬레이션하는 겁니다.</p>

<code class="notranslate" translate="no">gl.POINTS</code>에는 2가지 문제가 있는데요.

<ol>
<li>
최대 크기를 가집니다.<br/><br/>
<code class="notranslate" translate="no">gl.POINTS</code>를 사용하는 대부분의 사람들은 작은 크기를 사용하지만 최대 크기가 필요한 것보다 작으면 다른 해결책을 선택해야 할 겁니다.
</li>
<li>
화면 밖에 있을 때 잘리는 방법이 일치하지 않습니다.<br/><br/>
포인트의 중심을 캔버스 왼쪽 가장자리에서 1픽셀 떨어진 곳으로 설정했지만 <code class="notranslate" translate="no">gl_PointSize</code>를 32.0으로 설정했다고 상상해보세요.
<div class="webgl_center"><img src="../resources/point-outside-canvas.svg" style="width: 400px"></div>
OpenGL ES 1.0 스펙에 따르면 32x32 픽셀의 15개 열이 여전히 캔버스에 있기 때문에 이 부분이 그려져야 합니다.
안타깝지만 OpenGL(ES 아님)은 정반대인데요.
포인트의 중심이 캔버스를 벗어나면 아무것도 그려지지 않습니다.
게다가 OpenGL은 최근까지 테스트 수준이 낮기로 악명 높았기 때문에 일부 드라이버는 이러한 픽셀을 그리기도 하고 안 그리기도 합니다 😭
</li>
</ol>
<p>
따라서 당신이 필요한 게 이러한 문제들 중 하나를 가질 경우, 해결책으로 <code class="notranslate" translate="no">gl.POINTS</code>를 사용하는 대신에 <code class="notranslate" translate="no">gl.TRIANGLES</code>로 전용 쿼드를 그려야 하는데요.
그렇게 하면 두 문제 모두 해결됩니다.
일치하지 않는 클리핑 문제와 마찬가지로 최대 크기 문제도 사라집니다.
쿼드를 많이 그리는 여러 방법이 있습니다.
그 중 하나는 이 글에 나온 기술 등을 사용하는 겁니다.
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-drawing-without-data.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-drawing-without-data.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-drawing-without-data.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-drawing-without-data.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-drawing-without-data.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-drawing-without-data.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-drawing-without-data.html" >Русский</a>
    <option value="/webgl/lessons/uk/webgl-drawing-without-data.html" >Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-drawing-without-data.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로드</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일이 있는 .obj 로드</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">인스턴스 드로잉</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
<div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
<div class="lesson-comment-notes">
  코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 데이터 없이 그리기';
            var disqus_title = 'WebGL 데이터 없이 그리기';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



