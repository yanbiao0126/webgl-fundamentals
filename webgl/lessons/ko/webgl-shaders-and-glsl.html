<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-shaders-and-glsl.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="셰이더는 뭐고 GLSL은 뭘까?">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg">

<meta property="og:title" content="WebGL 셰이더와 GLSL">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg">
<meta property="og:description" content="셰이더는 뭐고 GLSL은 뭘까?">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 셰이더와 GLSL">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">
<meta name="twitter:description" content="셰이더는 뭐고 GLSL은 뭘까?">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html",
      "inLanguage":"ko",
      "name":"WebGL 셰이더와 GLSL",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 셰이더와 GLSL</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shaders-and-glsl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-shaders-and-glsl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 셰이더와 GLSL</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이 글은 <a href="webgl-fundamentals.html">WebGL 기초</a>에서 이어집니다.
아직 <a href="webgl-how-it-works.html">WebGL 작동 방식</a>를 읽지 않았다면 먼저 읽어보는 게 좋습니다.</p>
<p>셰이더와 GLSL에 대해 언급했지만 실제로 구체적인 세부 사항은 다루지 않았는데요.
예제로 충분하면 좋겠지만 혹시 모르니 좀 더 확실하게 해봅시다.</p>
<p><a href="webgl-how-it-works.html">작동 원리</a>에서 언급했듯이 WebGL은 뭔가를 그릴 때마다 2개의 셰이더를 필요로 하는데요.
바로 <em>정점 셰이더</em>와 <em>프래그먼트 셰이더</em>입니다.
각각의 셰이더는 <em>함수</em>인데요.
정점 셰이더와 프래그먼트 셰이더는 함께 셰이더 프로그램(또는 그냥 프로그램)으로 연결됩니다.
일반적인 WebGL 앱은 많은 셰이더 프로그램을 가집니다.</p>
<h2 id="-">정점 셰이더</h2>
<p>정점 셰이더의 역할은 클립 공간 좌표를 생성하는 겁니다.
항상 이런 형식을 취하는데요.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">void main() {
  gl_Position = doMathToMakeClipspaceCoordinates
}
</code></pre><p>셰이더는 정점마다 한 번씩 호출됩니다.
호출될 때마다 특수 전역 변수, <code class="notranslate" translate="no">gl_Position</code>을 어떤 클립 공간 좌표로 설정해야 합니다.</p>
<p>정점 셰이더는 데이터가 필요한데요.
3가지 방법으로 데이터를 가져올 수 있습니다.</p>
<ol>
<li><a href="#attribute">속성</a> (버퍼에서 가져온 데이터)</li>
<li><a href="#uniform">유니폼</a> (단일 그리기 호출의 모든 정점에 대해 동일하게 유지되는 값)</li>
<li><a href="#vertex-shader-texture">텍스처</a> (픽셀/텍셀 데이터)</li>
</ol>
<div id="attribute"></div>

<h3 id="-">속성</h3>
<p>가장 일반적인 방법은 버퍼와 <em>속성</em>을 통하는 겁니다.
<a href="webgl-how-it-works.html">작동 원리</a>에서 버퍼와 속성을 다뤘었죠.
먼저 버퍼를 만들고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var buf = gl.createBuffer();
</code></pre><p>이 버퍼에 데이터를 넣은 뒤,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);
</code></pre><p>만든 셰이더 프로그램을 통해 초기화 시 속성의 위치를 찾고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionLoc = gl.getAttribLocation(someShaderProgram, &quot;a_position&quot;);
</code></pre><p>렌더링할 때 해당 버퍼에서 속성으로 데이터를 어떻게 가져올지 WebGL에 지시하는데,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 이 속성의 버퍼에서 데이터 가져오기 활성화
gl.enableVertexAttribArray(positionLoc);

var numComponents = 3;  // (x, y, z)
var type = gl.FLOAT;    // 32비트 부동 소수점 값
var normalize = false;  // 값 원본 그대로 유지
var offset = 0;         // 버퍼의 처음부터 시작
var stride = 0;         // 다음 정점으로 가기 위해 이동하는 바이트 수
                        // 0 = `type`과 `numComponents`에 맞는 스트라이드 사용

gl.vertexAttribPointer(positionLoc, numComponents, type, false, stride, offset);
</code></pre><p><a href="webgl-fundamentals.html">WebGL 기초</a>에서 우리는 셰이더에서 수식을 사용하지 않고 데이터를 직접 전달했습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;

void main() {
  gl_Position = a_position;
}
</code></pre><p>클립 공간 정점을 버퍼에 넣으면 동작할 겁니다. </p>
<p>속성은 타입으로 <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, <code class="notranslate" translate="no">vec4</code>, <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code>, <code class="notranslate" translate="no">mat4</code>를 사용할 수 있습니다.</p>
<div id="uniform"></div>

<h3 id="-">유니폼</h3>
<p>셰이더 유니폼은 그리기 호출의 모든 정점에 대해 동일하게 유지되며 셰이더에 전달되는 값입니다.
간단한 예로 위의 정점 셰이더에 오프셋을 추가할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
+uniform vec4 u_offset;

void main() {
  gl_Position = a_position + u_offset;
}
</code></pre><p>이제 모든 정점을 일정량만큼 오프셋 할 수 있습니다.
먼저 초기화 시 유니폼의 위치를 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var offsetLoc = gl.getUniformLocation(someProgram, &quot;u_offset&quot;);
</code></pre><p>그런 다음 그리기 전에 유니폼을 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform4fv(offsetLoc, [1, 0, 0, 0]);  // 화면 오른쪽 절반으로 오프셋
</code></pre><p>참고로 유니폼은 개별 셰이더 프로그램에 속합니다.
만약 이름이 같은 유니폼을 가진 셰이더 프로그램이 여러 개 있다면, 두 유니폼 모두 고유한 위치와 값을 가지는데요.
<code class="notranslate" translate="no">gl.uniform???</code>을 호출하면 <em>현재 프로그램</em>의 유니폼만 설정합니다.
현재 프로그램은 <code class="notranslate" translate="no">gl.useProgram</code>에 전달한 마지막 프로그램입니다.</p>
<p>유니폼은 여러 타입을 가질 수 있는데요.
각 타입마다 설정을 위해 해당하는 함수를 호출해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1f (floatUniformLoc, v);                 // float
gl.uniform1fv(floatUniformLoc, [v]);               // float 또는 float 배열
gl.uniform2f (vec2UniformLoc, v0, v1);             // vec2
gl.uniform2fv(vec2UniformLoc, [v0, v1]);           // vec2 또는 vec2 배열
gl.uniform3f (vec3UniformLoc, v0, v1, v2);         // vec3
gl.uniform3fv(vec3UniformLoc, [v0, v1, v2]);       // vec3 또는 vec3 배열
gl.uniform4f (vec4UniformLoc, v0, v1, v2, v4);     // vec4
gl.uniform4fv(vec4UniformLoc, [v0, v1, v2, v4]);   // vec4 또는 vec4 배열

gl.uniformMatrix2fv(mat2UniformLoc, false, [  4x element array ])  // mat2 또는 mat2 배열
gl.uniformMatrix3fv(mat3UniformLoc, false, [  9x element array ])  // mat3 또는 mat3 배열
gl.uniformMatrix4fv(mat4UniformLoc, false, [ 16x element array ])  // mat4 또는 mat4 배열

gl.uniform1i (intUniformLoc, v);                   // int
gl.uniform1iv(intUniformLoc, [v]);                 // int 또는 int 배열
gl.uniform2i (ivec2UniformLoc, v0, v1);            // ivec2
gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          // ivec2 또는 ivec2 배열
gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        // ivec3
gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      // ivec3 또는 ivec3 배열
gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    // ivec4
gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  // ivec4 또는 ivec4 배열

gl.uniform1i (sampler2DUniformLoc, v);             // sampler2D (texture)
gl.uniform1iv(sampler2DUniformLoc, [v]);           // sampler2D 또는 sampler2D 배열

gl.uniform1i (samplerCubeUniformLoc, v);           // samplerCube (texture)
gl.uniform1iv(samplerCubeUniformLoc, [v]);         // samplerCube 또는 samplerCube 배열
</code></pre><p><code class="notranslate" translate="no">bool</code>, <code class="notranslate" translate="no">bvec2</code>, <code class="notranslate" translate="no">bvec3</code>, <code class="notranslate" translate="no">bvec4</code> 타입도 있는데요.
<code class="notranslate" translate="no">gl.uniform?f?</code> 또는 <code class="notranslate" translate="no">gl.uniform?i?</code> 함수를 사용합니다.</p>
<p>배열의 경우 배열의 모든 유니폼을 한번에 설정할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 셰이더
uniform vec2 u_someVec2[3];

// 초기화 시 자바스크립트
var someVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2&quot;);

// 렌더링할 때
gl.uniform2fv(someVec2Loc, [1, 2, 3, 4, 5, 6]);  // u_someVec2의 전체 배열 설정
</code></pre><p>하지만 배열의 개별 요소를 설정하고 싶다면 각 요소의 위치를 개별적으로 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 초기화 시 자바스크립트
var someVec2Element0Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[0]&quot;);
var someVec2Element1Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[1]&quot;);
var someVec2Element2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[2]&quot;);

// 렌더링할 때
gl.uniform2fv(someVec2Element0Loc, [1, 2]);  // 요소 0 설정
gl.uniform2fv(someVec2Element1Loc, [3, 4]);  // 요소 1 설정
gl.uniform2fv(someVec2Element2Loc, [5, 6]);  // 요소 2 설정
</code></pre><p>마찬가지로 구조체를 생성하면,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">struct SomeStruct {
  bool active;
  vec2 someVec2;
};
uniform SomeStruct u_someThing;
</code></pre><p>각 필드를 개별적으로 찾아야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someThingActiveLoc = gl.getUniformLocation(someProgram, &quot;u_someThing.active&quot;);
var someThingSomeVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someThing.someVec2&quot;);
</code></pre><div id="vertex-shader-texture"></div>

<h3 id="-">정점 셰이더의 텍스처</h3>
<p><a href="#fragment-shader-texture">프래그먼트 셰이더의 텍스처</a>를 봐주세요.</p>
<h2 id="-">프래그먼트 셰이더</h2>
<p>프래그먼트 셰이더의 역할은 래스터화되는 현재 픽셀의 색상을 제공하는 것입니다.
항상 이런 형식을 취하는데요.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

void main() {
  gl_FragColor = doMathToMakeAColor;
}
</code></pre><p>프래그먼트 셰이더는 각 픽셀마다 한 번씩 호출됩니다.
호출될 때마다 특수 전역 변수, <code class="notranslate" translate="no">gl_FragColor</code>를 어떤 색상으로 설정해줘야 합니다.</p>
<p>프래그먼트 셰이더는 데이터가 필요한데요.
3가지 방법으로 데이터를 가져올 수 있습니다.</p>
<ol>
<li><a href="#uniform">유니폼</a> (단일 그리기 호출의 모든 정점에 대해 동일하게 유지되는 값)</li>
<li><a href="#fragment-shader-texture">텍스처</a> (픽셀/텍셀 데이터)</li>
<li><a href="#varying">베링</a> (정점 셰이더에서 전달되고 보간된 데이터)</li>
</ol>
<h3 id="-">프래그먼트 셰이더의 유니폼</h3>
<p><a href="#uniform">셰이더의 유니폼</a>을 봐주세요.</p>
<div id="fragment-shader-texture"></div>

<h3 id="-">프래그먼트 셰이더의 텍스처</h3>
<p>셰이더의 텍스처에서 값을 가져오면 <code class="notranslate" translate="no">sampler2D</code> 유니폼을 생성하고 값을 추출하기 위해 GLSL 함수 <code class="notranslate" translate="no">texture2D</code>를 사용합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

uniform sampler2D u_texture;

void main() {
  vec2 texcoord = vec2(0.5, 0.5);  // 텍스처 중앙에서 값 가져오기
  gl_FragColor = texture2D(u_texture, texcoord);
}
</code></pre><p>텍스처에서 나오는 데이터는 <a href="webgl-3d-textures.html">수많은 설정</a>에 따라 달라집니다.
최소한의 텍스처 데이터를 생성하고 넣어 보겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
var level = 0;
var width = 2;
var height = 1;
var data = new Uint8Array([
  255, 0, 0, 255,   // 빨강 픽셀
  0, 255, 0, 255,   // 초록 픽셀
]);
gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
</code></pre><p>초기화 시 셰이더 프로그램의 유니폼 위치를 찾으며,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someSamplerLoc = gl.getUniformLocation(someProgram, &quot;u_texture&quot;);
</code></pre><p>렌더링할 때 텍스처 유닛에 텍스처를 할당하고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var unit = 5;  // 텍스처 유닛 선택
gl.activeTexture(gl.TEXTURE0 + unit);
gl.bindTexture(gl.TEXTURE_2D, tex);
</code></pre><p>텍스처를 바인딩한 유닛이 무엇인지 셰이더에 알려줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1i(someSamplerLoc, unit);
</code></pre><h3 id="-">베링</h3>
<p>베링은 <a href="webgl-how-it-works.html">동작 원리</a>에 다룬 정점 셰이더에서 프래그먼트 셰이더로 값을 전달하는 방법입니다.</p>
<p>베링을 사용하려면 정점 셰이더와 프래그먼트 셰이더 양쪽에 일치하는 베링을 선언해야 하는데요.
각 정점마다 정점 셰이더의 베링을 어떤 값으로 설정합니다.
WebGL이 픽셀을 그릴 때 이 값들 사이를 보간하고 프래그먼트 셰이더에서 대응하는 베링으로 전달할 겁니다.</p>
<p>정점 셰이더:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;

uniform vec4 u_offset;

+varying vec4 v_positionWithOffset;

void main() {
  gl_Position = a_position + u_offset;
+  v_positionWithOffset = a_position + u_offset;
}
</code></pre><p>프래그먼트 셰이더:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

+varying vec4 v_positionWithOffset;

void main() {
+  // 클립 공간에서 (-1 &lt;-&gt; +1) color space로 (0 -&gt; 1) 변환
+  vec4 color = v_positionWithOffset * 0.5 + 0.5;
+  gl_FragColor = color;
}
</code></pre><p>위 예제는 사실 말도 안되는 예제입니다.
일반적으로는 클립 공간 값을 프래그먼트 셰이더에 직접 복사해서 색상으로 사용하지 않는데요.
그럼에도 불구하고 이 코드는 작동하며 색상을 만들어냅니다.</p>
<h2 id="glsl">GLSL</h2>
<p>GLSL은 Graphics Library Shader Language의 약자로 셰이더가 작성되는 언어입니다.
이 언어는 자바스크립트에서 흔하지 않은 특별한 준 고유 기능을 가지고 있는데요.
그래픽 래스터화에 일반적으로 필요한 수학적 계산을 수행하도록 설계되었습니다.
예를 들어 각각 2개의 값, 3개의 값, 4개의 값을 나타내는 <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, <code class="notranslate" translate="no">vec4</code> 같은 타입들이 내장되어 있는데요.
마찬가지로 2x2, 3x3, 4x4 행렬을 나타내는 <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code>, <code class="notranslate" translate="no">mat4</code>가 있습니다.
<code class="notranslate" translate="no">vec</code>에 스칼라를 곱하는 등의 작업을 수행할 수도 있죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 a = vec4(1, 2, 3, 4);
vec4 b = a * 2.0;
// 현재 b는 vec4(2, 4, 6, 8);
</code></pre><p>마찬가지로 행렬 곱셈과 벡터 대 행렬 곱셈을 할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">mat4 a = ???
mat4 b = ???
mat4 c = a * b;

vec4 v = ???
vec4 y = c * v;
</code></pre><p>또한 vec 부분에 대한 다양한 선택자가 있습니다.
vec4를 보면,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 v;
</code></pre><ul>
<li><code class="notranslate" translate="no">v.x</code>는 <code class="notranslate" translate="no">v.s</code>와 <code class="notranslate" translate="no">v.r</code>과 <code class="notranslate" translate="no">v[0]</code>과 같습니다.</li>
<li><code class="notranslate" translate="no">v.y</code>는 <code class="notranslate" translate="no">v.t</code>와 <code class="notranslate" translate="no">v.g</code>와 <code class="notranslate" translate="no">v[1]</code>과 같습니다.</li>
<li><code class="notranslate" translate="no">v.z</code>는 <code class="notranslate" translate="no">v.p</code>와 <code class="notranslate" translate="no">v.b</code>와 <code class="notranslate" translate="no">v[2]</code>와 같습니다.</li>
<li><code class="notranslate" translate="no">v.w</code>는 <code class="notranslate" translate="no">v.q</code>와 <code class="notranslate" translate="no">v.a</code>와 <code class="notranslate" translate="no">v[3]</code>과 같습니다.</li>
</ul>
<p>vec 컴포넌트를 <em>스위즐링</em> 할 수 있는데 이는 컴포넌트를 교환하거나 반복할 수 있다는 걸 뜻합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.yyyy
</code></pre><p>이건 다음과 같고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.y, v.y, v.y, v.y)
</code></pre><p>마찬가지로,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.bgra
</code></pre><p>이건 다음과 같으며,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.b, v.g, v.r, v.a)
</code></pre><p>vec이나 mat을 만들 때 한 번에 여러 파트를 제공할 수도 있습니다.
예를 들어 이것은,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.rgb, 1)
</code></pre><p>다음과 같고,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.r, v.g, v.b, 1)
</code></pre><p>또한 이것은,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(1)
</code></pre><p>다음과 같은데,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(1, 1, 1, 1)
</code></pre><p>한 가지 주의해야할 점은 GLSL의 타입이 매우 엄격하다는 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1;  // ERROR: 1은 int입니다. float에는 int를 할당할 수 없습니다.
</code></pre><p>올바른 방법은 다음 중 하나입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1.0;      // float 사용
float f = float(1)  // integer를 float로 캐스팅
</code></pre><p>위 예제의 <code class="notranslate" translate="no">vec4(v.rgb, 1)</code>는 <code class="notranslate" translate="no">vec4</code>가 내부에서 <code class="notranslate" translate="no">float(1)</code>처럼 캐스팅하기 때문에 <code class="notranslate" translate="no">1</code>에 대해 문제가 발생하지 않습니다.</p>
<p>GLSL은 많은 내장 함수들을 가지고 있는데요.
대부분은 여러 컴포넌트에서 한 번에 작동합니다.
예를 들어,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">T sin(T angle)
</code></pre><p>T는 <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, <code class="notranslate" translate="no">vec4</code>가 될 수 있음을 뜻합니다.
만약 <code class="notranslate" translate="no">vec4</code>를 전달하면 각 컴포넌트의 사인 값인 <code class="notranslate" translate="no">vec4</code>를 돌려받습니다.
다시 말해 <code class="notranslate" translate="no">v</code>가 <code class="notranslate" translate="no">vec4</code>라면,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = sin(v);
</code></pre><p>다음과 같습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));
</code></pre><p>가끔은 한 매개변수가 float고 나머지는 <code class="notranslate" translate="no">T</code>가 됩니다.
이는 모든 컴포넌트에 float가 적용된다는 걸 뜻하는데요.
예를 들어 <code class="notranslate" translate="no">v1</code>과 <code class="notranslate" translate="no">v2</code>가 <code class="notranslate" translate="no">vec4</code>이고 <code class="notranslate" translate="no">f</code>는 float라면,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = mix(v1, v2, f);
</code></pre><p>다음과 같습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = vec4(
  mix(v1.x, v2.x, f),
  mix(v1.y, v2.y, f),
  mix(v1.z, v2.z, f),
  mix(v1.w, v2.w, f)
);
</code></pre><p><a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf">WebGL 레퍼런스 카드</a>의 마지막 페이지에서 모든 GLSL 함수 목록을 볼 수 있습니다.
만약 정말 재미없고 장황한 걸 좋아한다면 <a href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL 명세서</a>에 도전해볼 수도 있습니다.</p>
<h2 id="-">총정리</h2>
<p>이게 바로 모든 글들의 핵심입니다.
WebGL은 다양한 셰이더를 생성하고, 데이터를 셰이더에 제공한 다음, <code class="notranslate" translate="no">gl.drawArrays</code>나 <code class="notranslate" translate="no">gl.drawElements</code>를 호출하여 WebGL이 정점을 처리하도록 각 정점에 대한 현재 정점 셰이더를 호출한 뒤, 각 픽셀에 대한 현재 프래그먼트 셰이더를 호출하여 픽셀을 렌더링하는 것에 관한 모든 것입니다.</p>
<p>실제로 셰이더를 생성하려면 여러 줄의 코드가 필요합니다.
이 코드들은 대부분의 WebGL 프로그램에서 똑같기 때문에 한 번 작성한 후에는 거의 생략할 수 있습니다.
GLSL 셰이더를 컴파일하고 셰이더 프로그램에 연결하는 방법은 <a href="webgl-boilerplate.html">여기</a>에서 다룹니다.</p>
<p>여기에서 막 시작했다면 두 가지 방향으로 갈 수 있는데요.
이미지 처리에 관심있다면 <a href="webgl-image-processing.html">2D 이미지 처리 방법</a>을 보시면 됩니다.
평행 이동, 회전, 스케일 그리고 최종적으로 3D를 공부하는데 관심있다면 <a href="webgl-2d-translation.html">여기</a>부터 시작해주세요.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-shaders-and-glsl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-shaders-and-glsl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - 선반 가공</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">색인된 그리기</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 셰이더와 GLSL';
            var disqus_title = 'WebGL 셰이더와 GLSL';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



