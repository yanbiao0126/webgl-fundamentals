<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-how-it-works.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGL이 실제로 하는 일">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ko.jpg">

<meta property="og:title" content="WebGL 작동 방식">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ko.jpg">
<meta property="og:description" content="WebGL이 실제로 하는 일">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL 작동 방식">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html">
<meta name="twitter:description" content="WebGL이 실제로 하는 일">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html",
      "inLanguage":"ko",
      "name":"WebGL 작동 방식",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL 작동 방식</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-how-it-works.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-how-it-works.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-how-it-works.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-how-it-works.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-how-it-works.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-how-it-works.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-how-it-works.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-how-it-works.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-how-it-works.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-how-it-works.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 작동 방식</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>이건 <a href="webgl-fundamentals.html">WebGL 기초</a>에서 이어지는 글입니다.
이어서 하기 전에 WebGL과 GPU가 실제로 무엇을 하는지 기본적인 수준에서 얘기해봅시다.
GPU에는 기본적으로 2가지 파트가 있는데요.
첫 번째 파트는 정점(또는 데이터 스트림)을 클립 공간의 정점으로 처리합니다.
두 번째 파트는 첫 번째 부분을 기반으로 픽셀을 그립니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 9;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>위와 같이 호출할 때 9는 &quot;정점 9개 처리&quot;를 의미하고 다음과 같이 9개의 정점이 처리되고 있습니다.</p>
<p><img src="../resources/vertex-shader-anim.gif" class="webgl_center" /></p>
<p>왼쪽은 여러분이 제공한 데이터입니다.
정점 셰이더는 <a href="webgl-shaders-and-glsl.html">GLSL</a>로 작성하는 함수인데요.
이 함수는 각 정점마다 한 번씩 호출됩니다.
몇 가지 계산한 다음 현재 정점의 클립 공간 값으로 특수 변수 <code class="notranslate" translate="no">gl_Position</code>을 설정하죠.
GPU는 이 값을 가져와서 내부에 저장합니다.</p>
<p><code class="notranslate" translate="no">TRIANGLES</code>를 그린다고 가정하면, 첫 번째 부분에서 정점 3개를 생성할 때마다 GPU는 이걸 이용해 삼각형을 만듭니다.
어떤 픽셀이 삼각형의 점 3개에 해당하는지 확인한 다음, 삼각형을 래스터화(=&quot;픽셀로 그리기&quot;)하는데요.
각 픽셀마다 프래그먼트 셰이더를 호출해서 어떤 색상으로 만들지 묻습니다.
프래그먼트 셰이더는 특수 변수 <code class="notranslate" translate="no">gl_FragColor</code>를 해당 픽셀에 원하는 색상으로 설정해야 합니다.</p>
<p>지금까지 예제에서 볼 수 있듯이 프래그먼트 셰이더는 픽셀마다 아주 적은 정보를 가지고 있는데요.
다행히 더 많은 정보를 전달할 수 있습니다.
정점 셰이더에서 프래그먼트 셰이더로 전달하려는 각 값에 대해 “베링”을 정의하는 겁니다.</p>
<p>간단한 예시로 우리가 직접 계산한 클립 공간 좌표를 정점 셰이더에서 프래그먼트 셰이더로 전달해봅시다.</p>
<p>간단한 삼각형을 그려보려고 하는데요.
<a href="webgl-2d-matrices.html">이전 예제</a>에 이어서 사각형을 삼각형으로 바꿔봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 삼각형을 정의한 값으로 버퍼 채우기
function setGeometry(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
           0, -100,
         150,  125,
        -175,  100
      ]),
      gl.STATIC_DRAW
  );
}
</code></pre><p>그리고 3개의 정점만 그리면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 장면 그리기
function drawScene() {
  ...
  // 지오메트리 그리기
  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = 3;
  gl.drawArrays(primitiveType, offset, count);
}
</code></pre><p>다음은 프래그먼트 셰이더로 데이터를 전달하기 위해 정점 셰이더에 <em>베링</em>을 선언합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*varying vec4 v_color;
...
void main() {
  // 위치에 행렬 곱하기
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);

  // 클립 공간에서 색상 공간으로 변환
  // 클립 공간은 -1.0에서 +1.0까지
  // 색상 공간은 0.0에서 1.0까지
*  v_color = gl_Position * 0.5 + 0.5;
}
</code></pre><p>그런 다음 프래그먼트 셰이더에 동일한 <em>베링</em>을 선언합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

*varying vec4 v_color;

void main() {
*  gl_FragColor = v_color;
}
</code></pre><p>WebGL은 정점 셰이더의 베링을 이름과 타입이 같은 프래그먼트 셰이더의 베링으로 연결할 겁니다.</p>
<p>다음은 작동하는 버전입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-triangle-with-position-for-color.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-triangle-with-position-for-color.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>삼각형을 이동시키고, 크기를 바꾸고, 회전시켜보세요.
참고로 색상은 클립 공간에서 계산되므로 삼각형과 함께 움직이지 않는데요.
색상은 배경에 상대적입니다.</p>
<p>이제 생각해봅시다.
우리는 정점 3개만을 계산했습니다.
정점 셰이더는 3번만 호출되므로 3개의 색상만을 계산하지만 삼각형은 여러 색상입니다.
이게 <em>베링</em>이라고 불리는 이유죠.</p>
<p>WebGL은 각 정점을 계산한 3개의 값을 가져오고 삼각형을 래스터화할 때 계산된 정점들 사이를 보간하는데요.
각 픽셀마다 해당 픽셀에 대해 보간된 값으로 프래그먼트 셰이더를 호출합니다.</p>
<p>위 예제에서는 3개의 정점으로 시작합니다.</p>
<p><style>
table.vertex_table {
  border: 1px solid black;
  border-collapse: collapse;
  font-family: monospace;
  font-size: small;
}</p>
<p>table.vertex_table th {
  background-color: #88ccff;
  padding-right: 1em;
  padding-left: 1em;
}</p>
<p>table.vertex_table td {
  border: 1px solid black;
  text-align: right;
  padding-right: 1em;
  padding-left: 1em;
}
</style></p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="2">정점</th></tr>
<tr><td>0</td><td>-100</td></tr>
<tr><td>150</td><td>125</td></tr>
<tr><td>-175</td><td>100</td></tr>
</table>
</div>

<p>정점 셰이더는 <code class="notranslate" translate="no">translation</code>, <code class="notranslate" translate="no">rotation</code>, <code class="notranslate" translate="no">scale</code>에 행렬을 적용하고 클립 공간으로 변환합니다.
<code class="notranslate" translate="no">translation</code>, <code class="notranslate" translate="no">rotation</code>, <code class="notranslate" translate="no">scale</code>의 기본값은 translation = 200, 150, rotation = 0, scale = 1,1이므로 실제로는 이동만 하는데요.
400x300인 백버퍼가 주어지면 정점 셰이더는 행렬을 적용한 뒤 다음과 같은 3개의 클립 공간 정점을 계산합니다.</p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">gl_Position에 작성된 값들</th></tr>
<tr><td>0.000</td><td>0.660</td></tr>
<tr><td>0.750</td><td>-0.830</td></tr>
<tr><td>-0.875</td><td>-0.660</td></tr>
</table>
</div>

<p>또한 이걸 색상 공간으로 변환하고 우리가 선언한 <em>varying</em> <code class="notranslate" translate="no">v_color</code>에 작성합니다.</p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">v_color에 작성된 값들</th></tr>
<tr><td>0.5000</td><td>0.830</td><td>0.5</td></tr>
<tr><td>0.8750</td><td>0.086</td><td>0.5</td></tr>
<tr><td>0.0625</td><td>0.170</td><td>0.5</td></tr>
</table>
</div>

<p>v_color에 작성된 3개의 값들은 보간되어 각 픽셀에 대한 프래그먼트 셰이더로 전달됩니다.</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 600px; height: 400px;" src="/webgl/lessons/resources/fragment-shader-anim.html"></iframe>
  <div class="webgl_center">v_color는 v0, v1, v2 사이에서 보간</div>
</div>

</p>
<p>또한 더 많은 데이터를 정점 셰이더에 전달하여 프래그먼트 셰이더에 전달할 수 있습니다.
예를 들어 2가지 색상을 가진 삼각형 2개로 이루어진 사각형을 그린다고 가정해봅시다.
이를 위해 정점 셰이더에 또 다른 속성을 추가하면, 더 많은 데이터를 전달할 수 있고, 그 데이터를 프래그먼트 셰이더에 직접 전달할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec2 a_position;
+attribute vec4 a_color;
...
varying vec4 v_color;

void main() {
  ...
  // 속성에서 베링으로 색상 복사
*  v_color = a_color;
}
</code></pre><p>이제 WebGL이 사용할 색상을 제공해줘야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 정점 데이터가 필요한 곳 탐색
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
+var colorLocation = gl.getAttribLocation(program, &quot;a_color&quot;);
...
+// 색상을 위한 버퍼 생성
+var colorBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+// 색상 설정
+setColors(gl);
...

+// 사각형을 만드는 두 삼각형의 색상으로 버퍼 채우기
+function setColors(gl) {
+  // 2개의 색상을 랜덤하게 선택
+  var r1 = Math.random();
+  var b1 = Math.random();
+  var g1 = Math.random();
+
+  var r2 = Math.random();
+  var b2 = Math.random();
+  var g2 = Math.random();
+
+  gl.bufferData(
+    gl.ARRAY_BUFFER,
+    new Float32Array([
+      r1, b1, g1, 1,
+      r1, b1, g1, 1,
+      r1, b1, g1, 1,
+      r2, b2, g2, 1,
+      r2, b2, g2, 1,
+      r2, b2, g2, 1
+    ]),
+    gl.STATIC_DRAW
+  );
+}
</code></pre><p>렌더링할 때 색상 속성을 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+gl.enableVertexAttribArray(colorLocation);
+
+// 색상 버퍼 할당
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+
+// colorBuffer(ARRAY_BUFFER)의 데이터를 가져오는 방법을 색상 속성에 지시
+var size = 4;          // 반복마다 4개의 컴포넌트
+var type = gl.FLOAT;   // 데이터는 32비트 부동 소수점
+var normalize = false; // 데이터 정규화 안 함
+var stride = 0;        // 0 = 다음 위치를 가져오기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동
+var offset = 0;        // 버퍼의 처음부터 시작
+gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);
</code></pre><p>삼각형 2개의 정점 6개를 계산하기 위해 <code class="notranslate" translate="no">count</code>를 조정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 지오메트리 그리기
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>그리고 여기 결과물입니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-2-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-2-colors.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>2개의 단색 삼각형이라는 점에 주목해봅시다.
베링에 값이 전달되기 때문에 삼각형을 가로질러 변형되거나 보간되고 있는데요.
그럼에도 단색인 것은 각 삼각형의 정점 3개에 모두 같은 색상을 사용했기 때문입니다.
만약 각각의 색상을 다르게 만들면 보간된 걸 볼 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 사각형을 만드는 두 삼각형의 색상으로 버퍼 채우기
function setColors(gl) {
  // 모든 정점을 다른 색상으로 만들기
  gl.bufferData(
    gl.ARRAY_BUFFER,
*    new Float32Array([
*      Math.random(), Math.random(), Math.random(), 1,
*      Math.random(), Math.random(), Math.random(), 1,
*      Math.random(), Math.random(), Math.random(), 1,
*      Math.random(), Math.random(), Math.random(), 1,
*      Math.random(), Math.random(), Math.random(), 1,
*      Math.random(), Math.random(), Math.random(), 1
*    ]),
    gl.STATIC_DRAW
  );
}
</code></pre><p>이제 보간된 <em>베링</em>을 봅시다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-random-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-random-colors.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>2개 이상의 속성을 사용하고 데이터를 정점 셰이더에서 프래그먼트 셰이더로 전달하는 걸 보여주는데요.
<a href="webgl-image-processing.html">이미지 처리 예제</a>를 살펴보면 텍스처 좌표를 전달하기 위해 마찬가지로 추가적인 속성을 사용하는 것을 볼 수 있습니다.</p>
<h2 id="-">버퍼와 속성 명령은 어떤 일을 하나요?</h2>
<p>버퍼는 정점과 각 정점의 다른 데이터를 GPU로 가져오는 방법입니다.
<code class="notranslate" translate="no">gl.createBuffer</code>는 버퍼를 생성합니다.
<code class="notranslate" translate="no">gl.bindBuffer</code>는 해당 버퍼를 작업할 버퍼로 설정하죠.
<code class="notranslate" translate="no">gl.bufferData</code>는 데이터를 버퍼로 복사합니다.
이건 보통 초기화할 때 수행됩니다.</p>
<p>버퍼에 데이터가 있으면 어떻게 데이터를 가져와 정점 셰이더의 속성에 제공할지 WebGL에 알려줘야 합니다.</p>
<p>이를 위해, 먼저 속성을 할당한 위치를 WebGL에 물어봐야 하는데요.
예를 들어 위 코드에서 우리는 이렇게 위치를 찾았습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 정점 데이터가 어디로 가야하는지 탐색
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
var colorLocation = gl.getAttribLocation(program, &quot;a_color&quot;);
</code></pre><p>이것도 보통 초기화할 때 수행됩니다.</p>
<p>속성의 위치를 알았으면 그리기 전에 3가지 명령어를 실행해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(location);
</code></pre><p>이 명령어는 버퍼에서 데이터를 제공하길 원한다고 WebGL에 알려줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer);
</code></pre><p>이 명령어는 ARRAY_BUFFER 바인드 포인트에 버퍼를 할당합니다.
이건 WebGL 내부에 있는 전역 변수입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.vertexAttribPointer(
  location,
  numComponents,
  typeOfData,
  normalizeFlag,
  strideToNextPieceOfData,
  offsetIntoBuffer
);
</code></pre><p>그리고 이 명령어는 현재 ARRAY_BUFFER 바인드 포인트에 바인딩된 버퍼에서 데이터를 가져오기 위해,
정점마다 얼마나 많은 컴포넌트(1 - 4)가 있는지,
데이터 타입(<code class="notranslate" translate="no">BYTE</code>, <code class="notranslate" translate="no">FLOAT</code>, <code class="notranslate" translate="no">INT</code>, <code class="notranslate" translate="no">UNSIGNED_SHORT</code>, 등등...)은 무엇인지,
스트라이드는 한 데이터에서 다음 데이터를 가져오기 위해 몇 바이트를 건너뛰어야 하는지,
오프셋은 버퍼에서 데이터가 얼마나 멀리 있는지 등을 WebGL에 알려줍니다.</p>
<p>컴포넌트의 숫자는 항상 1에서 4까지의 범위를 가집니다.</p>
<p>만약 데이터의 타입마다 1개의 버퍼를 쓴다면 스트라이드와 오프셋은 항상 0일 수 있습니다.
스트라이드가 0이면 &quot;타입 크기에 맞는 스트라이드 사용&quot;을 의미합니다.
오프셋이 0이면 &quot;버퍼의 처음부터 시작&quot;을 의미합니다.
0 이외의 다른 값으로 설정하는 건 더욱 복잡하고 성능 면에서 어느 정도 이점이 있긴 하지만, WebGL을 한계까지 몰아붙이기 위한 게 아니라면 복잡함을 감수할만한 가치는 없을 것 같습니다.</p>
<p>버퍼와 속성이 무엇인지 정리되셨기를 바랍니다.</p>
<p>WebGL의 작동 방식을 이해하는 또 다른 방법으로 <a href="/webgl/lessons/resources/webgl-state-diagram.html">대화형 상태 다이어그램</a>을 살펴보실 수 있습니다.</p>
<p>다음은 <a href="webgl-shaders-and-glsl.html">셰이더와 GLSL</a>을 살펴보겠습니다.</p>
<div class="webgl_bottombar">
<h3>vertexAttribPointer에서 normalizeFlag는 뭔가요?</h3>
<p>
정규화 플래그는 부동 소수점이 아닌 모든 타입을 위한 것입니다.
`false`를 넘기면 해당 값의 타입으로 해석됩니다.
BYTE는 -128에서 127까지, UNSIGNED_BYTE는 0부터 255까지, SHORT는 -32768부터 32767까지 등등...
</p>
<p>
정규화 플래그를 `true`로 설정하면 BYTE(-128 ~ 127) 값은 -1.0에서 +1.0사이가 되고, UNSIGNED_BYTE(0 ~ 255)는 0.0에서 +1.0사이가 됩니다.
정규화된 SHORT도 -1.0에서 +1.0사이가 되며 BYTE보다 더 높은 해상도를 가집니다.
</p>
<p>
정규화된 데이터의 가장 일반적인 용도는 색상입니다.
대부분의 경우 색상은 0.0에서 1.0사이의 값을 가지는데요.
빨강, 초록, 파랑, 투명도 각각에 대해 전체 부동 소수점을 사용하며 각 정점의 색상마다 16바이트를 사용합니다.
복잡한 지오메트리가 있는 경우 많은 바이트가 추가될 수 있습니다.
대신에 0은 0.0이 되고 255는 1.0이 되는 UNSIGNED_BYTE로 색상을 변환할 수 있는데요.
그러면 각 정점의 색상마다 4바이트만 써서, 75%를 아낄 수 있습니다.
</p>
<p>
그렇게 하도록 코드를 수정해봅시다.
먼저 사용할 색상을 추출하는 방법을 WebGL에 지시합니다.
</p>
<pre class="prettyprint showlinemods">
// colorBuffer(ARRAY_BUFFER)에서 데이터를 어떻게 가져올지 색상 속성에 지시
var size = 4;                 // 반복마다 4개의 컴포넌트
*var type = gl.UNSIGNED_BYTE;  // 데이터는 8비트 부호없는 바이트
*var normalize = true;         // 데이터 정규화
var stride = 0;               // 0 = 다음 위치를 가져오기 위해 반복마다 size * sizeof(type) 만큼 앞으로 이동
var offset = 0;               // 버퍼의 처음부터 시작
gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);
</pre>
<p>그리고 사용할 색상으로 버퍼를 채웁니다.</p>
<pre class="prettyprint showlinemods">
// 사각형을 만드는 두 삼각형의 색상으로 버퍼 채우기
function setColors(gl) {
  // 2개의 색상을 랜덤하게 선택
  var r1 = Math.random() * 256; // 0에서
  var b1 = Math.random() * 256; // 255.99999사이의
  var g1 = Math.random() * 256; // 값은
  var r2 = Math.random() * 256; // Uint8Array에
  var b2 = Math.random() * 256; // 저장될 때
  var g2 = Math.random() * 256; // 잘림

  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Uint8Array([   // Uint8Array
      r1, b1, g1, 255,
      r1, b1, g1, 255,
      r1, b1, g1, 255,
      r2, b2, g2, 255,
      r2, b2, g2, 255,
      r2, b2, g2, 255
    ]),
    gl.STATIC_DRAW
  );
}
</pre>
<p>다음은 해당 샘플입니다.</p>
<div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-2-byte-colors.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-2-byte-colors.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>


</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-how-it-works.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-how-it-works.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-how-it-works.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-how-it-works.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-how-it-works.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-how-it-works.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-how-it-works.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-how-it-works.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 방식</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">셰이더와 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D 평행 이동, 회전, 스케일, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D 평행 이동</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D 회전</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D 스케일</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D 직교 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D 원근 투영</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">유틸리티 함수</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>지오메트리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">지오메트리 - 선반 가공</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">교차 출처 이미지</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">스프라이트</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">큐브맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">환경맵</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">스카이박스</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">스키닝</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">안개</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">피킹 (물체 클릭)</a></li>
        </ul>
  <li>텍스트</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - 글리프 텍스처 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">램프 텍스처 (툰 셰이딩)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">최소 프로그램</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">데이터 없이 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">정점 풀링</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">색인된 정점 (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">색인된 그리기</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">상용구</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">캔버스 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">다중 뷰, 다중 캔버스</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">카메라 시각화</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL 알파</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">안티 패턴</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">캔버스 지우기 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">크로스 플랫폼 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">속성</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">텍스처 유닛</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">프레임 버퍼</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 작동 방식';
            var disqus_title = 'WebGL 작동 방식';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



