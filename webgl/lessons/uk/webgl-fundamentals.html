<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/uk/webgl-fundamentals.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="uk">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Ваш перший урок WebGL починається з основ">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_uk.jpg">

<meta property="og:title" content="Основи WebGL">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_uk.jpg">
<meta property="og:description" content="Ваш перший урок WebGL починається з основ">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="Основи WebGL">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html">
<meta name="twitter:description" content="Ваш перший урок WebGL починається з основ">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_uk.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-fundamentals_uk.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html",
      "inLanguage":"uk",
      "name":"Основи WebGL",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html#primaryimage"
      }
    }
  ]
}
</script>


<title>Основи WebGL</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-fundamentals.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-fundamentals.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-fundamentals.html">
  <link rel="alternate" hreflang="uk" href="https://webglfundamentals.org/webgl/lessons/uk/webgl-fundamentals.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-fundamentals.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-fundamentals.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-fundamentals.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/uk/webgl-fundamentals.html" selected>Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


    <a href="#toc">Зміст</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/uk/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Основи WebGL</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL (Web Graphics Library) часто розглядають як 3D API. Люди думають: &quot;Я використаю WebGL і <em>магія</em> в мене вийде круте 3D&quot;. В реальності ж <a href="webgl-2d-vs-3d-library.html">WebGL це лише засіб растеризації</a>. Він малює точки, лінії та трикутники на основі коду, який ви йому надаєте. Те, як змусити WebGL робити що-небудь окрім цього залежить від вас і вашого коду, який використовуючи <a href="webgl-points-lines-triangles.html">точки, лінії та трикутники</a> здатний буде виконати ваше завдання.</p>
<p>WebGL виконується на графічному процесорі вашого комп’ютера. Саме тому ви маєте надати код, який працюватиме на цьому графічному процесорі. Цей код подається у вигляді двох функцій. Ці дві функції називають вершинним шейдером та фрагментним шейдером і кожна з них написана на строго типізованій С-подібній мові, яка називається
<a href="webgl-shaders-and-glsl.html">GLSL</a> (GL Shader Language). Разом вони називаються <em>програмою</em>.</p>
<p>Робота вершинного шейдера обчислити позицію вершини. На основі позиції, яку обчислює ця функція, WebGL може растеризувати різні види примітивів такі, як
<a href="webgl-points-lines-triangles.html">точки, лінії та трикутники</a>.
Під час растеризації цих примітивів WebGL викликає іншу функцію, яку ми називаємо фрагментним шейдером. Завданням фрагментного шейдера є обчислення кольору кожного пікселя того примітиву, який зараз відмальовується.</p>
<p>Практично все API WebGL полягає в тому, щоб <a href="../resources/webgl-state-diagram.html">налаштувати стан</a> для роботи цих двох функцій. Для будь-чого, що ви хочете намалювати ви маєте налаштувати декілька станів та запустити пару функції викликаючи <code class="notranslate" translate="no">gl.drawArrays</code> або <code class="notranslate" translate="no">gl.drawElements</code> які запустять виші шейдери на графічному процесорі.</p>
<p>Будь-які дані, які мають бути доступними для цих функції необхідно надати графічному процесору. Є 4 способи, якими шейдер може отримати дані:</p>
<ol>
<li><p>Атрибути та Буфери</p>
<p>Буфери це масиви бінарних даних, які ви завантажили на графічний процесор. Зазвичай буфери містять такі речі як позиції, нормалі, координати текстур, кольори вершин, та ін. Проте, ви можете помітисти в них будь-що, що вам заманеться.</p>
<p>Атрибути використовуються для визначення способу отримати дані з буферів і передети їх у вершинні шейдери. Наприклад, ви можете помістити певні позиції в буфері у вигляді трьох 32-бітних чисел з рухомою комою. Ви б могли вказати певному атрибуту, з якого буфера йому витягувати позиції, якого типу даних вони повинні бути (три 32-бітних числа з рухомою комою), зміщення в буфері, з якого починається певна позиція та скільки байтів зчитати до наступної позиції.</p>
<p>Буфери не мають можливості довільного доступу. Натомість, вершинний шейдер виконується певну задану кількість разів. Кожного разу, коли він виконується, з буфера витягується наступне значення і присвоюється атрибуту.</p>
</li>
<li><p>Uniform-змінні </p>
<p>Uniforms - глобальні змінні, які ви встановлюєте перед тим, як запустити програму шейдера.</p>
</li>
<li><p>Текстури</p>
<p>Текстури це масиви даних, які мають можливість довільного доступу у ваших шейдерних програмах. Зазвичай в текстури поміщають дані зображення, але текстури це лише дані, тому вони можуть так само легко містити щось, крім кольорів.</p>
</li>
<li><p>Varying-змінні</p>
<p>Varying-змінні - це спосіб передачі даних з вершинного шейдерв в фрагметний шейдер. Залежно від того, що зараз рендериться, точки, лінії чи трикутники, значення встановленні вершинним шейдером в varyings-змінні будуть інтерпольовані під час виконання фрагментного шейдера.  </p>
</li>
</ol>
<h2 id="-webgl">&quot;Привіт, світе!&quot; у WebGL</h2>
<p>WebGL переймається тільки двома речими: координатами простору відсікання (clip space) та кольорами. Ваше завдання, як програміста, передати ці дві речі до WebGL. Це робиться з допомогою ваших двох шейдерів. Вершинного шейдеру, який надає координати простору кадру та фрагментного шейдеру, який надає колір.</p>
<p>Координати простору відсікання завжди лежать в діапазоні від -1 до +1 незалежно від розміру полотна. </p>
<div class="webgl_center"><img src="../resources/clipspace.svg" style="width: 400px"></div>

<p>Ось невеликий приклад WebGL, який показує його в найпростіший формі.</p>
<p>Почнімо з вершинного шейдера:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// атрибут отримає дані з буфера
attribute vec4 a_position;

// всі шейдери мають головну функцію main
void main() {
  // gl_Position - особлива зміннна, за встановлення якої
  // відповідає вершинний шейдер
  gl_Position = a_position;
}
</code></pre><p>Якби цей код був би написаний на JavaScript замість GLSL, то його робота виглядала б так:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// *** PSEUDO CODE!! ***

var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;

drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i &lt; count; ++i) {
     // копіюємо 4 значення з positionBuffer до a_position атрибута
     const start = offset + i * stride;
     attributes.a_position = positionBuffer.slice(start, start + size);
     runVertexShader();
     ...
     doSomethingWith_gl_Position();
}
</code></pre><p>В реальності все не настільки просто тому, що <code class="notranslate" translate="no">positionBuffer</code> потрібно перевести в бінарні дані (дивись нижче) і тому справжні обчислення для отримання даних з буфера будуть виглядати по-іншому, але сподіваємось, що це дасть вам ідею того як вершинний шейдер буде виконуватись.  </p>
<p>Далі нам потрібен фрагментний шейдер:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// фрагментний шейдер за замовчуванням немає встановленої точності
// тому нам потрібно її обрати. mediump хороше значення за замовчуванням
// mediump означає середня точність
precision mediump float;

void main() {
  // gl_FragColor - особлива змінна, за встановлення якої
  // відповідає фрагментний шейдер
  gl_FragColor = vec4(1, 0, 0.5, 1); // повернути червонувато-фіолетовий колір
}
</code></pre><p>Вище ми встановлюємо значення <code class="notranslate" translate="no">gl_FragColor</code> в <code class="notranslate" translate="no">1, 0, 0.5, 1</code>, де 1 - червоний, 0 - зелений,
0.5 - синій та 1 - альфа канал. Кольори в WebGL задаються в діапазоні від 0 до 1.</p>
<p>Тепер, коли ми створили дві функції з шейдерами ми можемо перейти до WebGL.</p>
<p>Спочатку нам потрібно створити HTML елемент canvas:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre><p>Після цього, ми можемо отримати цей елемент в JavaScript:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var canvas = document.querySelector(&quot;#c&quot;);
</code></pre><p>Тепер ми можемо створити WebGLRenderingContext</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> var gl = canvas.getContext(&quot;webgl&quot;);
 if (!gl) {
    // webgl для вас недоступний!
    ...
</code></pre><p>Далі нам потрібно скомпілювати шейдери для того, щоб помістити їх в графічний процесор тож спочатку нам потрібно перетворити їх у текстові рядки. Ви можете створити ці GLSL рядки у будь-який зручний спосіб, у який ви зазвичай створюєте їх у JavaScript: з допомогою конкатинації, з допомогою AJAX запиту, використовуючи шаблонні літерали, або, як у цьому випадку, вставляючи їх у скриптовий тег позначений як не-JavaScript (notjs): </p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;vertex-shader-2d&quot; type=&quot;notjs&quot;&gt;
  // атрибут отримає дані з буфера
  attribute vec4 a_position;

  // всі шейдери мають головну функцію main
  void main() {
    // gl_Position - особлива змінна, за встановлення якої
    // відповідає вершинний шейдер
    gl_Position = a_position;
  }

&lt;/script&gt;

&lt;script id=&quot;fragment-shader-2d&quot; type=&quot;notjs&quot;&gt;
  // фрагментний шейдер за замовчуванням немає встановленої точності
  // тому нам потрібно її обрати. mediump хороше значення за замовчуванням
  // mediump означає середня точність
  precision mediump float;

  void main() {
    // gl_FragColor - особлива змінна, за встановлення якої
    // відповідає фрагментний шейдер
    gl_FragColor = vec4(1, 0, 0.5, 1); // повернути червонувато-фіолетовий колір
  }

&lt;/script&gt;
</code></pre><p>Насправді більшість 3D-рушіїв генерують шейдери GLSL на льоту, використовуючи різні типи шаблонів, конкатенацію тощо. Як приклад шейдери на цьому сайті, хоча жоден із них не є настільки складним, щоб генерувати GLSL під час виконання.</p>
<p>Далі нам потрібна функція, яка створить шейдер, завантажить вихідний код GLSL і скомпілює його. Зверніть увагу, що ми не додавали жодних коментарів, тому, що з назви функцій має бути і так зрозуміло що відбувається:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}
</code></pre><p>Тепер ми можемо викликати цю функцію, щоб створити наші два шейдера:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var vertexShaderSource = document.querySelector(&quot;#vertex-shader-2d&quot;).text;
var fragmentShaderSource = document.querySelector(&quot;#fragment-shader-2d&quot;).text;

var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
</code></pre><p>Далі нам потрібно <em>пов’язати</em> (<em>to link</em>) ці шейдери з <em>програмою</em> (<em>program</em>):</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}
</code></pre><p>І створити її:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var program = createProgram(gl, vertexShader, fragmentShader);
</code></pre><p>Тепер, коли ми створили програму GLSL, яка виконуватиметься на графічному процесорі, нам потрібно надати їй певні дані. Більшість WebGL API стосується налаштування стану для надання даних нашим GLSL програмам. У цьому випадку єдиними вхідними даними для нашої програми GLSL є змінна <code class="notranslate" translate="no">a_position</code>, яка є атрибутом. Перше, що нам варто зробити, це знайти розташування атрибута програми, яку ми щойно створили:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre><p>Пошук розташування атрибута (та uniform-змінної) це щось, що потрібно робити саме на етапі ініціалізації програми, а не під час циклу рендерингу.</p>
<p>Атрибути отримують дані з буферів, тому нам потрібно створити новий буфер:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionBuffer = gl.createBuffer();
</code></pre><p>WebGL дозволяє нам маніпулювати багатьма ресурсами WebGL за допомогою точок прив’язки. Ви можете розглядати точки прив’язки як внутрішні глобальні змінні всередині WebGL. Спочатку ви прив’язуєте певний ресурс до однієї з точок прив’язки. Після цього усі інші функції будуть посилатись на цей ресурс саме через цю точку прив’язки. Отже, давайте прив’яжемо наш буфер з позиціями до однієї з таких точок:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre><p>Тепер ми можемо помістити певні дані в цей буфер, з допомогою точки прив’язки:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// три 2d точки
var positions = [
  0, 0,
  0, 0.5,
  0.7, 0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>В цьому коді відбувається багато цікавого. По-перше, у нас є змінна <code class="notranslate" translate="no">positions</code>, яка є
масивом JavaScript. WebGL зі свого боку потребує строгої типізації даних, тому ця частина <code class="notranslate" translate="no">new Float32Array(positions)</code> відповідає за перетворення масиву <code class="notranslate" translate="no">positions</code> в новий масив 32-бітних чисел з рухомою комою. Далі <code class="notranslate" translate="no">gl.bufferData</code> копіює ці дані в <code class="notranslate" translate="no">positionBuffer</code>, який зберігається на графічному процесорі. Ми використовуємо точку прив’язки <code class="notranslate" translate="no">ARRAY_BUFFER</code>, яка посилається на <code class="notranslate" translate="no">positionBuffer</code>, щоб скопіювати дані саме туди.</p>
<p>Останній аргумент, <code class="notranslate" translate="no">gl.STATIC_DRAW</code>, є підказкою для WebGL про те, як ми будемо використовувати ці дані. WebGL може спробувати використати цю підказку для оптимізації певних речей. <code class="notranslate" translate="no">gl.STATIC_DRAW</code> повідомляє WebGL, що ми не плануємо змінювати ці дані часто.</p>
<p>Увесь код до цього моменту був <em>кодом ініціалізації</em>. Код, який запуститься тоді, коли ми завантажемо сторінку. Код, який ми розглядатимемо надалі це <em>код рендерингу</em>, який буде виконуватись кожен раз, коли ми захочемо відрендерити/намалювати щось.</p>
<h2 id="-">Рендеринг</h2>
<p>Перш ніж почати щось малювати, ми маємо змінити розмір полотна відповідно до розміру дисплея. Полотно так само як і зображення має 2 розміри. Перший, це фактична кількість пікселів у нії, а другий це фактичний розмір, яким вона відображаються на екрані. CSS задає розмір
відображення на екрані. <strong>Ви завжди повинні встановлювати розмір полотна за допомогою CSS</strong>, оскільки це найбільш гнучкий метод серед інших.</p>
<p>Щоб кількість пікселів полотна збігалась з розміром відображення <a href="webgl-resizing-the-canvas.html">я використовую допоміжну функцію, про яку можна почитати тут</a>.</p>
<p>Майже в усіх цих прикладах розмір полотна становить 400x300 пікселів, якщо приклад запускається в окремому вікні, але розтягується, щоб заповнити доступний простір, якщо він розташовується всередині iframe, як на цій сторінці.
Дозволяючи CSS визначати розмір, а потім коригуючи його до потрібного ми з легкістю впораємось з обома випадками:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre><p>Нам потрібно вказати WebGL як конвертувати значення простору відсікання, які ми задамо в <code class="notranslate" translate="no">gl_Position</code>, назад в пікселі, які часто називають простором екрану. Для цього ми викликаємо функцію <code class="notranslate" translate="no">gl.viewport</code> і передаємо їй поточний розмір полотна.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre><p>Це повідомляє WebGL, що значеня простору відсікання від -1 до +1 перетворюється в значення від 0 до <code class="notranslate" translate="no">gl.canvas.width</code> для координат по x та від 0 до <code class="notranslate" translate="no">gl.canvas.height</code> для координат по y.</p>
<p>Далі ми очищуємо полотно. Встановлюючи значення <code class="notranslate" translate="no">0, 0, 0, 0</code> для червоного, зеленого, синього та альфа-каналу ми робимо полотно повністю прозорим:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Очищаємо полотно
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre><p>Тут ми повідомляємо WebGL яку саме програму потрібно запустити:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// вказуємо на потрібну програму (шейдерну пару)
gl.useProgram(program);
</code></pre><p>Тепер нам потрібно повідомити WebGL, як отримати дані з буфера, який ми створили вище, і надавати їх атрибуту у шейдері. Спочатку нам потрібно увімкнути атрибут:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre><p>Далі потрібно описати як саме отримати ці дані:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Прив’язуємо буфер з позиціями.
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// вказуємо атрибуту на те, як витягнути звідти дані
var size = 2;          // 2 складові на кожну ітерацію
var type = gl.FLOAT;   // тип даних - 32-бітні числа
var normalize = false; // нормалізувати дані не потрібно
var stride = 0;        // 0 = кожної ітерації просуватись по даних з кроком size * sizeof(type) для отримання наступної позиції
var offset = 0;        // починати від початку буфера
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset)
</code></pre><p>Прихована частина функції <code class="notranslate" translate="no">gl.vertexAttribPointer</code> полягає в тому, що вона прив’язує поточне значення <code class="notranslate" translate="no">ARRAY_BUFFER</code> до переданого атрибута. Іншими словами, тепер цей атрибут пов’язаний напряму з <code class="notranslate" translate="no">positionBuffer</code>. Це означає, що ми можемо використовувати <code class="notranslate" translate="no">ARRAY_BUFFER</code> як точку прив’язки для чогось іншого, а цей атрибут продовжить використовувати саме <code class="notranslate" translate="no">positionBuffer</code>.</p>
<p>Зверніть увагу, що, з точки зору нашого вершинного шейдера, атрибут <code class="notranslate" translate="no">a_position</code> має тип даних <code class="notranslate" translate="no">vec4</code>:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
</code></pre><p><code class="notranslate" translate="no">vec4</code> це значення з чотирьох чисел. В термінах JavaScript ви може виглядати як <code class="notranslate" translate="no">a_position = {x: 0, y: 0, z: 0, w: 0}</code>. Вище ми встановили <code class="notranslate" translate="no">size = 2</code>. Значення за замовчуванням для атрибута є <code class="notranslate" translate="no">0, 0, 0, 1</code>, тому цей атрибут отримає перші два значення (x та y) з нашого буфера, а наступні два (z та w) залишуться 0 та 1.</p>
<p>Після всього цього ми нарешті можемо попросити WebGL виконати нашу GLSL програму:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 3;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>Через те, що <code class="notranslate" translate="no">count</code> дорівнює 3, наший вершинний шейдер виконається 3 рази. Першого разу, значення <code class="notranslate" translate="no">a_position.x</code> та <code class="notranslate" translate="no">a_position.y</code> в атрибуті вершинного шейдера будуть встановленні з перших двох значень змінної <code class="notranslate" translate="no">positionBuffer</code>. Другого разу, значення <code class="notranslate" translate="no">a_position.x</code> та <code class="notranslate" translate="no">a_position.y</code> будуть встановленні в наступні два значення буфера. Останнього разу, вони будуть встановленні з останніх двох значень буфера.</p>
<p>Через те, що ми встановили значення <code class="notranslate" translate="no">primitiveType</code> як <code class="notranslate" translate="no">gl.TRIANGLES</code>, кожного разу, коли наш вершинний шейдер буде запускатись, WebGL буде малювати трикутник на основі 3 значень, які ми встановили для <code class="notranslate" translate="no">gl_Position</code>. Незалежно від розміру нашого полотна ці значення встановлюються в просторі відсікання, який, в свою чергу, лежить в межах від -1 до 1.</p>
<p>Вершинний шейдер просто копіює значення <code class="notranslate" translate="no">positionBuffer</code> до <code class="notranslate" translate="no">gl_Position</code>, тому трикутник буде намальований в таких координатих простору відсікання:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  0, 0,
  0, 0.5,
  0.7, 0,
</code></pre><p>Перетворюючи координати простору відсікання в координати простору екрану для полотна розміром 400x300 пікселів ми отримаємо такі значення:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> простір відсікання      простір екрану
   0, 0             -&gt;     200, 150
   0, 0.5           -&gt;     200, 225
   0.7, 0           -&gt;     340, 150
</code></pre><p>Тепер WebGL відрендирить цей трикутник. Для кожного пікселя, який він збирається намалювати, WebGL викличе наш фрагментний шейдер. Наш фрагментний шейдер просто встановлює значення <code class="notranslate" translate="no">gl_FragColor</code> як <code class="notranslate" translate="no">1, 0, 0.5, 1</code>. Оскільки елемент canvas для кожного каналу приймає 8-бітні значення, WebGL запише значення <code class="notranslate" translate="no">[255, 0, 127, 255]</code> в це полотно.</p>
<p>Ось інтерактивна версія нашого прикладу:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-fundamentals.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-fundamentals.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

</p>
<p>В цьому прикладі ви можете побачити, що вершинний шейдер лише передає далі дані про координати і більше нічого. Оскільки дані про позиції одразу задані в просторі відсікання, то тут немає додаткової роботи, яку потрібно виконати. <em>Якщо ви хочете відображати 3D об’єкти, то відповідальність за створення шейдерів, які перетворюють 3D координати в координати простору відсікання лежить на вас, тому що WebGL це тільки засіб растеризації</em>.</p>
<p>Вас може зацікавити чому цей трикутник починається посередині і прямує до правого верхнього кута. Простір відсікання лежить в значеннях від -1 до +1. Це означає, що 0 це центральна позиція і додатні значення прямуватимуть в праву сторону від нього.</p>
<p>Також, оскільки в просторі відсікання -1 це низ, а +1 це верх, то 0 це середина і додатні числа будуть вище цієї середини.</p>
<p>Для двовимірних задач вам мабуть буде зручніше працювати в піксельних значеннях ніш координатах простору відсікання. Тож давайте змінимо наш шейдер так, щоб ми могли передавати йому значення позицій в пікселях, які він самостійно буде перетворювати в координати простору відсікання. Ось наш новий шейдер:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;vertex-shader-2d&quot; type=&quot;notjs&quot;&gt;

-  attribute vec4 a_position;
*  attribute vec2 a_position;

+  uniform vec2 u_resolution;

  void main() {
+    // перетворюємо позиції з пікселів в діапазон від 0.0 до 1.0
+    vec2 zeroToOne = a_position / u_resolution;
+
+    // перетворюємо це з 0-&gt;1 до 0-&gt;2
+    vec2 zeroToTwo = zeroToOne * 2.0;
+
+    // перетворюємо цей діпазон з 0-&gt;2 до -1-&gt;+1
+    vec2 clipSpace = zeroToTwo - 1.0;
+
*    gl_Position = vec4(clipSpace, 0, 1);
  }

&lt;/script&gt;
</code></pre><p>Деякі важливі зміни, які варто зауважити. Ми змінили тип змінної <code class="notranslate" translate="no">a_position</code> на <code class="notranslate" translate="no">vec2</code> оскільки ми використовуємо тільки <code class="notranslate" translate="no">x</code> та <code class="notranslate" translate="no">y</code>. Тип <code class="notranslate" translate="no">vec2</code> схожий до <code class="notranslate" translate="no">vec4</code>, але має тільки <code class="notranslate" translate="no">x</code> та <code class="notranslate" translate="no">y</code>.</p>
<p>Далі ми додали uniform-змінну з назвою <code class="notranslate" translate="no">u_resolution</code>. Саме тому, нам потрібно дізнатись її розташування:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre><p>Рашту має бути зрозуміло з коментарів. Встановлюючи в змінну <code class="notranslate" translate="no">u_resolution</code> значення розширення нашого полотна ми тепер  можемо взяти позицію з <code class="notranslate" translate="no">positionBuffer</code> задану у пікселях і перетворити їх у координати простору відсікання.</p>
<p>Тепер ми можемо змінити координати наших позицій на пікселі. Цього разу ми збираємось намалювати чотирикутник, який складається з двох трикутників по 3 точки на кожен:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positions = [
*  10, 20,
*  80, 20,
*  10, 30,
*  10, 30,
*  80, 20,
*  80, 30,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>Після того, як ми зазначимо, яку саме програму використовувати, ми можемо встановити значення uniform-змінної, яку ми створили. Функція <code class="notranslate" translate="no">gl.useProgram</code> схожа на <code class="notranslate" translate="no">gl.bindBuffer</code> тим, що встановлює поточну програму. Після цього всі <code class="notranslate" translate="no">gl.uniformXXX</code> функції встановлюють значення uniform-змінним уже поточної програми:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.useProgram(program);

...

// встановити значення розширення
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
</code></pre><p>Звісно для того, щоб намалювати 2 трикутника, ми потребуємо, щоб WebGL викликав наш вершинний шейдер 6 разів:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// намалювати
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>Ось, що ми отримаємо.</p>
<p>Нотатка: Цей приклад і усі наступні приклади використовують файл <a href="/webgl/resources/webgl-utils.js"><code class="notranslate" translate="no">webgl-utils.js</code></a>, який містить в собі допоміжні функції для компіляції та прив’язки шейдерів. Немає потреби захаращувати наші приклади <a href="webgl-boilerplate.html">цим повторюваним</a> кодом.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

</p>
<p>Ви знову можете помітити, що прямокутник розташовується біля нижньої частини цієї зони. WebGL розглядає додатній y як верх, і від’ємний y як низ. У просторі відсікання нижній лівий кут має координати (-1, -1). Ми не міняли жодної знаків тож з поточною логікою нашого шейдера (0, 0) стає нижнім лівим кутом. Щоб перетворити це у більш традиційний для двовимірної графіки верхній лівий кут, ми можемо просто перевернути простір відсікання по координаті y.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre><p>Тепер наш прямокутник там, де ми очікуємо його побачити.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-top-left.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-top-left.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

</p>
<p>Давайте перетворимо код, який визначає прямокутник, у функцію, щоб ми могли викликати її для прямокутників різного розміру. Поки ми це робимо, ми налаштуємо колір.</p>
<p>Спочатку ми додаємо до фрагментного шейдера unifrom-змінну, яка прийматиме дані про колір.
First we make the fragment shader take a color uniform input.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">&lt;script id=&quot;fragment-shader-2d&quot; type=&quot;notjs&quot;&gt;
  precision mediump float;

+  uniform vec4 u_color;

  void main() {
*    gl_FragColor = u_color;
  }
&lt;/script&gt;
</code></pre><p>А ось і новий код, який малює 50 прямокутників у випадкових місцях і з випадковими кольорами.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  var colorUniformLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
  ...

  // намалювати 50 випадкових прямокутників
  for (var ii = 0; ii &lt; 50; ++ii) {
    // задати випадковий прямокутник
    setRectangle(
        gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

    // задати випадковий колір
    gl.uniform4f(colorUniformLocation, Math.random(), Math.random(), Math.random(), 1);

    // намалювати прямокутник
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
}

// повертає випадково значення від 0 до range - 1.
function randomInt(range) {
  return Math.floor(Math.random() * range);
}

// заповнює буфер значеннями, які описують прямокутник
function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;

  // gl.bufferData(gl.ARRAY_BUFFER, ...) буде впливати
  // на той буфер, який зараз прив’язаний до `ARRAY_BUFFER`.
  // Якби ми мали декілька буферів,
  // то спершу нам потрібно було б прив’язати той,
  // який ми хочемо використати

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}
</code></pre><p>Ось наші прямокутники:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangles.html" target="_blank">натисніть сюди, щоб відкрити в окремому вікні</a>
</div>

</p>
<p>Я сподіваюсь, що ви могли побачити, що WebGL насправді дуже простий. Гаразд, можливо, простий тут невдале слово. Точніше буде сказати, що WebGL робить прості речі. Він просто виконує 2 функції (вершинний та фрагментний шейдер) та малює трикутники, лінії та точки. Звісно, він може робити складні 3D речі, але цю складність можете додати тільки ви, програмісти, у вигляді більш складних шейдерів. WebGL сам по собі це лише засіб растеризації, досить простий концептуально.</p>
<p>Ми охопили невеликий приклад, який показав нам, як передавати дані в атрибути та uniform-змінні. Це досить поширено мати декілька атрибутів і багато uniform-змінних. На початку цієї статті ми також згадували про <em>varying-змінні</em> та <em>текстури</em>. Ці речі появляться в наступних уроках.</p>
<p>Перш ніж ми підемо далі, я хочу зазначити, що для <em>більшості</em> програм оновлення даних у буфері, як ми це робили в <code class="notranslate" translate="no">setRectangle</code>, не є звичною практикою. Я використав цей приклад, тому що вважав, що його найлегше пояснити, оскільки він показує координати пікселів як вхідні дані та демонструє виконання невеликої кількості математики в GLSL. Це також не є неправильно, є багато випадків, коли це цілком прийнятно, але ви повинні <a href="webgl-2d-translation.html">продовжувати читати, щоб дізнатися про більш поширений спосіб розташування, зміни орієнтації та масштабування речей у WebGL</a>.</p>
<p>Якщо ви новачок у веброзробці і навіть, якщо ні, то перегляньте <a href="webgl-setup-and-installation.html">Налаштування та встановлення</a> для деяких порад щодо розробки WebGL.</p>
<p>Якщо ви на 100% новачок у WebGL і не знаєте, що таке GLSL, шейдери чи що робить GPU то перегляньте <a href="webgl-how-it-works.html">основи того, як насправді працює WebGL</a>.
Ви також можете поглянути на <a href="/webgl/lessons/resources/webgl-state-diagram.html">інтерактивну діаграму стану</a> для іншого способу розуміння того, як працює WebGL.</p>
<p>Ви також мусите коротко прочитати про <a href="webgl-boilerplate.html">шаблон коду, який тут використовується</a> і який використовується в більшості прикладів. Також мусите хоча б пролистати про те, 
<a href="webgl-drawing-multiple-things.html">як малювати кілька речей</a>, щоб отримати певне уявлення про структуру більш типових програм WebGL, оскільки, майже всі приклади тут малюють лише одну річ і тому не показують цю структуру.</p>
<p>З цього місця ви можете йти у двох напрямках. Якщо вас цікавить обробка зображень, то можете глянути на те <a href="webgl-image-processing.html">як виконати базову обробку 2D зображень</a>. Якщо вам цікаво дізнатися про переміщення, обертання та масштабування та, зрештою, 3D, то <a href="webgl-2d-translation.html">почніть тут</a>.</p>
<div class="webgl_bottombar">
<h3>What does type="notjs" mean?</h3>
<p>
<code class="notranslate" translate="no">&lt;script&gt;</code> за замовчуванням містять в собі JavaScript код. Ви можете не описувати тип, вписати тип <code class="notranslate" translate="no">type="javascript"</code> або <code class="notranslate" translate="no">type="text/javascript"</code> і браузер автоматично виконає цей код, як JavaScript. Якщо ви вставете щось інше в <code class="notranslate" translate="no">type</code>, то браузер проігнорує вміст цього тегу. Іншими словами <code class="notranslate" translate="no">type="notjs"</code> не мають ніякого значення для браузера. 
<p>Це дозволяє легко редагувати наші шейдери. Інші альтернативи включають в себе рядкову конкатенацію:</p>
<pre class="prettyprint">
  var shaderSource =
    "void main() {\n" +
    "  gl_FragColor = vec4(1,0,0,1);\n" +
    "}";
</pre>
<p>або ж ми можемо завантажити шейдери за допомогою ajax запиту, що сповільнить роботу сайту.</p>
<p>Більш сучасний підхід - використати шаблонні літерали.</p>
<pre class="prettyprint">
  var shaderSource = `
    void main() {
      gl_FragColor = vec4(1,0,0,1);
    }
  `;
</pre>
<p> Шаблонні літерали працюють в більшості браузерів, які підтримують WebGL. На жаль, вони не працюють в дуже старих версіях браузерів. Якщо ви хочете підтримувати ці версії, вам прийдеться відмовитись від шаблонних літералів, або використати <a href="https://babeljs.io/">транспайлер</a>.
</p>
</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-fundamentals.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-fundamentals.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-fundamentals.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-fundamentals.html" >Русский</a>
    <option value="/webgl/lessons/uk/webgl-fundamentals.html" selected>Українська</a>
    <option value="/webgl/lessons/zh_cn/webgl-fundamentals.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основи</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-fundamentals.html">Основи</a></li>
<li><a href="/webgl/lessons/uk/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/uk/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>Обробка зображень</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/uk/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>Переміщення, обертання та масштабування в 2D просторі</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/uk/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/uk/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/uk/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/uk/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/uk/webgl-3d-camera.html">3D Cameras</a></li>
        </ul>
  <li>Освітлення</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/uk/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/uk/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Структура та організація</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/uk/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/uk/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Геометрія</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/uk/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/uk/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>Текстури</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/uk/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/uk/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/uk/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/uk/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/uk/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Тіні</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Прийоми</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/uk/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/uk/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/uk/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/uk/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/uk/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/uk/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/uk/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/uk/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/uk/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/uk/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>Текстури</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Поради</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/uk/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/uk/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/uk/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Оптимізація</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/uk/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Різне</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/uk/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/uk/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/uk/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/uk/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/uk/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/uk/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/uk/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/uk/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/uk/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/uk/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/uk/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/uk/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/uk/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/uk/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/uk/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/uk/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/uk/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Довідка</li>
        <ul>
          <li><a href="/webgl/lessons/uk/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/uk/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/uk/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/uk/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/uk/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Допоміжна документація по API</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Запитання? <a href="https://stackoverflow.com/questions/tagged/webgl">Запитати на stackoverflow</a>.</div>
<div>Помітили проблему чи баг? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Створити опис  проблеми на github</a>.</div>
<div class="lesson-comment-notes">
   Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Основи WebGL';
            var disqus_title = 'Основи WebGL';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



