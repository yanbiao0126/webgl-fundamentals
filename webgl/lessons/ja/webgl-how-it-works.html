<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ja/webgl-how-it-works.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGLが実際にはどのように動いているのかを説明する">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ja.jpg">

<meta property="og:title" content="WebGLの仕組み">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ja.jpg">
<meta property="og:description" content="WebGLが実際にはどのように動いているのかを説明する">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGLの仕組み">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html">
<meta name="twitter:description" content="WebGLが実際にはどのように動いているのかを説明する">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-how-it-works_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html",
      "inLanguage":"ja",
      "name":"WebGLの仕組み",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGLの仕組み</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-how-it-works.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-how-it-works.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-how-it-works.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-how-it-works.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-how-it-works.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-how-it-works.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-how-it-works.html" selected>日本語</a>
    <option value="/webgl/lessons/ko/webgl-how-it-works.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-how-it-works.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-how-it-works.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-how-it-works.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-how-it-works.html" >简体中文</a>
</select>


    <a href="#toc">目次</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ja/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGLの仕組み</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>この記事は「<a href="webgl-fundamentals.html">WebGLの基本</a>」の続きである。
WebGLの話を進めるに当たって、WebGLやGPUが、実際には
どのように動作しているのかを取り上げようと思う。</p>
<p>始めに押さえておきたいのは「GPUは２つのことをやる」という点である。
１点目は、「頂点データ(頂点座標に限らず、与えられたバッファ上のデータストリーム)」を
「クリップ空間の座標データに変換処理する」こと、
２点目は、「１つ目の処理の結果」を元に「ピクセルを描画する」ことである。</p>
<h2 id="-">頂点シェーダーの位置づけと役割</h2>
<p>WebGLのコードで、</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 9;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>と書いた場合、それは「９つの頂点データを処理せよ」という意味の、
GPUに対する命令である。</p>
<p><img src="../resources/vertex-shader-anim.gif" class="webgl_center" /></p>
<p>図中、左の&quot;Original Vertices&quot;(元となる頂点情報)は、あなた(プログラマ)が用意したデータである。</p>
<p>図中、中央の&quot;Vertex Shader&quot;(頂点シェーダー)とあるのは、
あなたが<a href="webgl-shaders-and-glsl.html">GLSL言語</a>で書いた関数である。
頂点シェーダーは、元となる頂点１つにつき１回呼び出される。
頂点シェーダーでは、呼び出しに使われた「元となる頂点情報」に対応する「クリップ空間上の値」を、
何らかの計算をして求め、その値を特別な変数である「<code class="notranslate" translate="no">gl_Position</code>」に書き込む。
GPUはその結果を取り出して、GPUが内部的に管理している専用の領域に保存する。</p>
<h2 id="-">ラスタライズ</h2>
<p>保存されたデータは、今回のコードでは<code class="notranslate" translate="no">drawArrays</code>呼び出しの際に「<code class="notranslate" translate="no">TRIANGLES</code>」を指定したので、
GPUは上記の処理を頂点３つ分繰り返すたびに、そこで得られた「クリップ空間上の値」
３つを使って三角形(triangle)を構成する。
これによって、「三角形の頂点」を画面上のどのピクセルに対応付ければ良いかが割り出され、
三角形が「ラスタライズ」、つまり、ファンシーな表現で言えば「ドット絵として、描かれる」
ことになる。</p>
<h2 id="-">フラグメントシェーダーの位置づけと役割</h2>
<p>GPUは、そうして描かれることになったピクセル一つ一つに対して、
あなたが提供したフラグメントシェーダーを呼び出して、
「そのピクセルはどんな色であるか」質問する。
フラグメントシェーダーは、特別な変数<code class="notranslate" translate="no">gl_FragColor</code>に値をセットしてこの質問に回答
しなければならない。</p>
<p>ラスタライズとフラグメントシェーダーの仕組みは興味深いものであるが、ご存知のように
前回の講義で用意したサンプルプログラムでは
「フラグメントシェーダーが各ピクセルの色について答える」という部分は非常に単純なコードであり、
ほとんど何もしていなかった。
もっと多くの情報をフラグメントシェーダーに渡すことができるので、今回はそれをやってみよう。</p>
<h2 id="varying-">varying変数</h2>
<p>頂点シェーダーからフラグメントシェーダーに情報を渡すために「varying」変数を使用する。
付け加えたい情報1件につき、1つの「varying」変数を定義する必要がある。</p>
<p>varyingの使い方の単純な例として、まずは「クリップ空間の座標データ」を
頂点シェーダーからフラグメントシェーダーに、そのまま、渡してみることにしよう。</p>
<p>今回は簡単な三角形を1つだけ描くことする。<a href="webgl-2d-matrices.html">前回のプログラム</a>
で長方形を描いていたところを、三角形を描くように書き換える。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 三角形を定義する頂点のデータをバッファにセットする
function setGeometry(gl) {
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
             0, -100,
           150,  125,
          -175,  100]),
      gl.STATIC_DRAW);
}
</code></pre><p>頂点数が3つになったので、シェーダーの呼び出し部分のcountも3に合わせる。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// シーン(scene)を描画する
function drawScene() {
  ...
  // 形状(geometry)を描画する
  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = 3;
  gl.drawArrays(primitiveType, offset, count);
}
</code></pre><p>頂点シェーダーで、フラグメントシェーダーに渡すべきデータを
<em>varying</em>変数として宣言する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*varying vec4 v_color;
...
void main() {
  // 座標データを行列で乗算する
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);

  // 「クリップ空間」から「色空間」へ変換する。
  // クリップ空間は -1.0 ～ +1.0
  // 色空間は 0.0 ～ 1.0
*  v_color = gl_Position * 0.5 + 0.5;
}
</code></pre><p>同じ<em>varying</em>変数を、フラグメントシェーダーでも宣言する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

*varying vec4 v_color;

void main() {
*  gl_FragColor = v_color;
}
</code></pre><p>これでWebGLは、「頂点シェーダで宣言されたvarying変数」を、
「同じ名前同じ型で宣言されたフラグメントシェーダー上のvarying変数」に接続する。</p>
<p>以上のコードを動かすと下のようになる。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-triangle-with-position-for-color.html%3Fui-angle%3D%25E8%25A7%2592%25E5%25BA%25A6%26ui-scaleX%3DX%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587%26ui-scaleY%3DY%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-triangle-with-position-for-color.html?ui-angle=%E8%A7%92%E5%BA%A6&ui-scaleX=X%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87&ui-scaleY=Y%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>上の画面でスライダを動かして、平行移動、回転、拡大縮小してみよう。
クリップ空間で計算された色が、三角形と共に動いていないことに気づいただろうか。
色は、背景に張り付いたような動きをしている。</p>
<p>ちょっと考えてみよう。今回頂点シェーダーで扱ったのは頂点３つだけである。
頂点シェーダーは３回だけ呼び出され、色についても３つの色を計算しただけである。
実際に表示されている三角形はたくさんの色で描かれているのに、である。
これは、<em>varying</em>の名前の由来、「vary＝変化する」に秘密がある。</p>
<p>WebGLは３頂点分の値を得て、２つのシェーダーを使ってそれを計算し、
頂点の間を「補間(つまり、あいだを補う)」することで三角形としてラスタライズしている。
フラグメントシェーダーは、この「補間によって三角形を構成することになったピクセル」
ひとつひとつについて１回ずつ呼び出されるのである。</p>
<p>上のサンプルでは、以下の３つの頂点情報を使っていた。</p>
<style>
table.vertex_table {
  border: 1px solid black;
  border-collapse: collapse;
  font-family: monospace;
  font-size: small;
}

table.vertex_table th {
  background-color: #88ccff;
  padding-right: 1em;
  padding-left: 1em;
}

table.vertex_table td {
  border: 1px solid black;
  text-align: right;
  padding-right: 1em;
  padding-left: 1em;
}
</style>

<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="2">頂点</th></tr>
<tr><td>0</td><td>-100</td></tr>
<tr><td>150</td><td>125</td></tr>
<tr><td>-175</td><td>100</td></tr>
</table>
</div>

<p>我々の頂点シェーダーは、この頂点データに行列を適用することで、「平行移動、
回転、拡大縮小、クリップ空間への変換」という４つの操作を行っている。
「平行移動」、「回転」、「拡大縮小」については、変換行列のデフォルト値は
「translation = (200, 150)」、「rotation = 0」、「scale = (1, 1)」だったので、
実際には平行移動しているだけである。
バックバッファは400x300としているので、「クリップ空間への変換」
によって上で示した３つの頂点座標は、以下の「クリップ空間座標上の値」に変換される。</p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="2">gl_Positionに書き込まれる値</th></tr>
<tr><td>0.000</td><td>0.660</td></tr>
<tr><td>0.750</td><td>-0.830</td></tr>
<tr><td>-0.875</td><td>-0.660</td></tr>
</table>
</div>

<p>さらに、この「クリップ空間上の値」を、「色空間上の値」に変換して、
今回宣言した<em>varying</em>変数のv_colorに書き込んでいる。</p>
<div class="hcenter">
<table class="vertex_table">
<tr><th colspan="3">v_colorに書き込まれる値</th></tr>
<tr><td>0.5000</td><td>0.830</td><td>0.5</td></tr>
<tr><td>0.8750</td><td>0.086</td><td>0.5</td></tr>
<tr><td>0.0625</td><td>0.170</td><td>0.5</td></tr>
</table>
</div>

<p>v_colorに書き込まれたこれら３つの値は、補間され、
描かれるピクセルごとにフラグメントシェーダーに渡される。</p>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 600px; height: 400px;" src="/webgl/lessons/resources/fragment-shader-anim.html"></iframe>
  <div class="webgl_center">v_colorは頂点v0, v1, v2の間で補間される</div>
</div>

</p>
<p>以上で「頂点シェーダー経由でフラグメントシェーダーにデータを渡す」ことができた。</p>
<h2 id="-">別の例</h2>
<p>次は、２つの、色違いの三角形で構成された長方形を描いてみよう。
フラグメントシェーダーに別のデータを送る。</p>
<p>まず頂点シェーダーがデータを受け取れるように、新たなattributeを追加する。
そしてその内容を、そのままフラグメントシェーダーに渡すようする。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec2 a_position;
+attribute vec4 a_color;
...
varying vec4 v_color;

void main() {
   ...
  // attributeで受け取った色のデータをvarying変数にコピーする。
*  v_color = a_color;
}
</code></pre><p>使いたい色のデータをWebGLに与える。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  // 頂点データの書き込み先となる、シェーダーのattributeのロケーションを得る。
  var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
+  var colorLocation = gl.getAttribLocation(program, &quot;a_color&quot;);
  ...
+  // 色データを渡すためのバッファーを生成する。
+  var colorBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+  // 色をセットするために用意した関数を呼び出す。
+  setColors(gl);
  ...

+// 長方形を構成する２つの三角形の色のデータを
+// バッファに書き込む。
+function setColors(gl) {
+  // 各三角形の色はランダム。
+  var r1 = Math.random();
+  var b1 = Math.random();
+  var g1 = Math.random();
+
+  var r2 = Math.random();
+  var b2 = Math.random();
+  var g2 = Math.random();
+
+  gl.bufferData(
+      gl.ARRAY_BUFFER,
+      new Float32Array(
+        [ r1, b1, g1, 1,
+          r1, b1, g1, 1,
+          r1, b1, g1, 1,
+          r2, b2, g2, 1,
+          r2, b2, g2, 1,
+          r2, b2, g2, 1]),
+      gl.STATIC_DRAW);
+}
</code></pre><p>レンダリングのタイミングで、色データのattributeをセットする。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+gl.enableVertexAttribArray(colorLocation);
+
+// colorBufferをバインドする。
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+
+// colorBuffer(ARRAY_BUFFER)に書き込んだデータを、
+// 頂点シェーダーがcolor attributeとしてどのように読み出すかを設定する。
+var size = 4;          // １回あたり４コンポーネント
+var type = gl.FLOAT;   // データは32bit浮動小数点数(float)
+var normalize = false; // データの正規化は行わない
+var stride = 0;        // 0 = 「次のデータはsize * sizeof(type)bytes先にある」という意味
+var offset = 0;        // バッファの先頭から
+gl.vertexAttribPointer(
+    colorLocation, size, type, normalize, stride, offset)
</code></pre><p>シェーダーを呼び出す部分では、三角形２つ＝６頂点なのでcountを6に変更する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// Draw the geometry.
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>実行結果はこのようになる。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-2-colors.html%3Fui-angle%3D%25E8%25A7%2592%25E5%25BA%25A6%26ui-scaleX%3DX%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587%26ui-scaleY%3DY%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-2-colors.html?ui-angle=%E8%A7%92%E5%BA%A6&ui-scaleX=X%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87&ui-scaleY=Y%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>それぞれ別の色の、単色の三角形が２つできた。WebGLで各頂点に対して
色のデータを指定して、GPUは各頂点の色のデータを頂点間で補間している。
今回は各三角形の３つの頂点に同じ色を指定したため、各三角形は単色になっている。
３頂点に別の色を指定して、頂点間で補間される様子を見たいなら
こんな風に変更すればよい。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 長方形を構成する２つの三角形の色のデータを
// バッファに書き込む。
function setColors(gl) {
* // 各頂点の色はランダム。
  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(
*        [ Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1,
*          Math.random(), Math.random(), Math.random(), 1]),
      gl.STATIC_DRAW);
}
</code></pre><p>これで、<em>varying</em>が補間されて「vary=変化」の様子がグラデーションとして見えるようなった。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-random-colors.html%3Fui-angle%3D%25E8%25A7%2592%25E5%25BA%25A6%26ui-scaleX%3DX%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587%26ui-scaleY%3DY%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-random-colors.html?ui-angle=%E8%A7%92%E5%BA%A6&ui-scaleX=X%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87&ui-scaleY=Y%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<h2 id="-">まとめ</h2>
<p>以上、別におもしろい結果ではなかったかも知れないが、これで「複数のattributeのデータを
頂点シェーダー経由でフラグメントシェーダーに渡す」ことができるようになった。
「<a href="webgl-image-processing.html">画像処理のサンプル</a>」では、この方法を応用して
シェーダーに対して「texture coordinate(テクスチャ内の座標)」を渡しているので、
興味があれば確認してみるとよいだろう。</p>
<h2 id="-attribute-">「バッファ」や「各attribute関係の関数」は何をしているのか？</h2>
<p>「バッファ」とは、GPUが「頂点データや各頂点と１対１で結びついたデータ」を
取り込むための仕組みである。
<code class="notranslate" translate="no">gl.createBuffer</code>はバッファを生成する。
<code class="notranslate" translate="no">gl.bindBuffer</code>は、操作対象のバッファを指定する。
<code class="notranslate" translate="no">gl.bufferData</code>は、バッファにデータをコピーする。
これは通常、初期化のタイミングで行なわれる。</p>
<p>「バッファにデータを入れる」ことができたら、
次は、「バッファからデータを取り出す手順」、
つまり「頂点シェーダーのattributeへと取り込む手順」をWebGLに教える必要がある。</p>
<p>シェーダーのコード中でattribute変数が宣言されていると、WebGLは、
各attributeに対して自動的にロケーション(location)を割り当てる。
まず、それがどこなのかをWebGLに対して尋ねる。上の例では</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 頂点データの書き込み先となる、シェーダーのattributeのロケーションを得る。
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
var colorLocation = gl.getAttribLocation(program, &quot;a_color&quot;);
</code></pre><p>の部分がこれに当たる。通常、この処理も初期化のタイミングで行なう。</p>
<p>attributeのロケーションが得られたら、描画する直前のタイミングで３つのコマンドを実行する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.enableVertexAttribArray(location);
</code></pre><p>１つめのコマンドは、WebGLに「データはバッファから渡す」と伝えるためのものである。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer);
</code></pre><p>２つめのコマンドは、「バッファ」を「<code class="notranslate" translate="no">ARRAY_BUFFER</code>バインドポイント」に
バインドする(バインド(bind)は「結びつける」といった意味である)。
<code class="notranslate" translate="no">ARRAY_BUFFER</code>は、WebGLが内部で定義しているグローバル変数である。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.vertexAttribPointer(
    location,
    numComponents,
    typeOfData,
    normalizeFlag,
    strideToNextPieceOfData,
    offsetIntoBuffer);
</code></pre><p>３つめのコマンドは、「現在ARRAY_BUFFERバインドポイントに結びつけられているバッファ
からデータを取得する」ように、WebGLに対して命令するもので、「numComponents：１つの
頂点に対していくつコンポーネントがあるか(1個～4個)」、「typeOfData：データの型
(<code class="notranslate" translate="no">BYTE</code>, <code class="notranslate" translate="no">FLOAT</code>, <code class="notranslate" translate="no">INT</code>, <code class="notranslate" translate="no">UNSIGNED_SHORT</code>など)はどれか」、
「strideToNextPieceOfData：次のデータまで何バイトあるか」、
「offsetIntoBuffer：オフセット」といった、データ取得に必要な情報が添えられる。</p>
<p>numComponentsは常に１個から４個である。</p>
<p>一種類のデータに対してバッファを一つ割り当てる場合、
「ストライド(strideToNextPieceOfData)」と「オフセット(offsetIntoBuffer)」は常に0となるだろう。
「ストライド」の値が0というのは、「ストライドの量が、データ型とサイズに相応」という意味である。
「オフセット」の値が0というのは、「バッファの先頭のデータから読み出す」という意味である。
これらを0以外の値とする場合、処理は複雑になってくる。
それによってWebGLのパフォーマンスを限界まで引き出すことができる場合もあるが、
複雑になることとのトレードオフに見合う状況は多くあるまい。</p>
<p>以上が「バッファ」と「属性(attribute)」についての説明となる。</p>
<p>次回は「<a href="webgl-shaders-and-glsl.html">シェーダーとGLSL</a>」について説明する。</p>
<div class="webgl_bottombar"><h3>vertexAttribPointer関数にある「normalizeFlag引数」は何をするもの？</h3>
<p>
normalizeFlag(日本語で書くなら「正規化フラグ」)は、float(不動小数点数)以外のデータ
を扱うためにある。このフラグにfalseをセットすると、各データ型のデータがそのまま解釈される。
具体的には、BYTE型データなら-128～127、UNSIGNED_BYTE型なら0～255、SHORT型なら-32768～32767……となる。
</p>
<p>
このフラグにtrueをセットすると、「BYTE型の-128～127の範囲のデータ」は-1.0～+1.0へ、
「UNSIGHNED_BYTE型の0～255の範囲のデータ」は0.0～+1.0へと「正規化」される。
SHORT型データも同様に-1.0～+1.0へと「正規化」されるが、BYTE型データよりもデータの解像度は高くなる。
</p>
<p>
normalizeFlagを使う典型的な例は色情報のデータである。ほとんどの場合、色情報は0.0～1.0の数値で指定される。
RGBA(赤、緑、青、透明度)それぞれにfloat型を使った場合、１頂点あたりの色情報は16バイトとなる。
ここで、色情報をUNSIGNED_BYTE型で表現して、0は0.0、255は1.0、となるようにすれば、１頂点あたりの色情報は４バイト、即ち、floatを使った場合と比較して75%節約できる。
こういった節約は、複雑なジオメトリデータを使う場合、つまり、頂点数が多くデータの大きさが問題となるような状況で有効である。
</p>
<p>実際にコーディングしてみよう。データの取り出し方を指定する部分はこのようなコードになる。</p>
<pre class="prettyprint showlinemods">
  // colorBuffer(ARRAY_BUFFER)に書き込んだデータを、
  // 頂点シェーダーがcolor attributeとしてどのように読み出すかを設定する。
  var size = 4;                 // １回あたり４コンポーネント
*  var type = gl.UNSIGNED_BYTE;  // データは8bitのUNSIGNED_BYTE型
*  var normalize = true;         // データを正規化する
  var stride = 0;               // 0 =「次のデータはsize * sizeof(type)bytes先にある」という意味
  var offset = 0;               // バッファの先頭から
  gl.vertexAttribPointer(
      colorLocation, size, type, normalize, stride, offset)
</pre>
<p>そしてバッファに色情報をセットするコードは次のようになる。</p>
<pre class="prettyprint showlinemods">
// 長方形を構成する２つの三角形の色のデータを
// バッファに書き込む。
function setColors(gl) {
  // 各三角形の色はランダム。
  var r1 = Math.random() * 256; // これは、0～255.99999の値を取る。
  var b1 = Math.random() * 256; // これらの値は、
  var g1 = Math.random() * 256; // この下のコードで、
  var r2 = Math.random() * 256; // Uint8Arrayにセットされる段階で
  var b2 = Math.random() * 256; // 小数部が切り捨てられる。
  var g2 = Math.random() * 256;

  gl.bufferData(
      gl.ARRAY_BUFFER,
      new Uint8Array(   // Uint8Array
        [ r1, b1, g1, 255,
          r1, b1, g1, 255,
          r1, b1, g1, 255,
          r2, b2, g2, 255,
          r2, b2, g2, 255,
          r2, b2, g2, 255]),
      gl.STATIC_DRAW);
}
</pre>
<p>
実行結果はこのようになる。
</p>

<div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-with-2-byte-colors.html%3Fui-angle%3D%25E8%25A7%2592%25E5%25BA%25A6%26ui-scaleX%3DX%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587%26ui-scaleY%3DY%25E6%2596%25B9%25E5%2590%2591%25E3%2581%25AE%25E6%258B%25A1%25E5%25A4%25A7%25E7%258E%2587"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-with-2-byte-colors.html?ui-angle=%E8%A7%92%E5%BA%A6&ui-scaleX=X%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87&ui-scaleY=Y%E6%96%B9%E5%90%91%E3%81%AE%E6%8B%A1%E5%A4%A7%E7%8E%87" target="_blank">クリックして別のウインドウを開く</a>
</div>


</div>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-how-it-works.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-how-it-works.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-how-it-works.html" selected>日本語</a>
    <option value="/webgl/lessons/ko/webgl-how-it-works.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-how-it-works.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-how-it-works.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-how-it-works.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-how-it-works.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-fundamentals.html">基本</a></li>
<li><a href="/webgl/lessons/ja/webgl-how-it-works.html">WebGLの仕組み</a></li>
<li><a href="/webgl/lessons/ja/webgl-shaders-and-glsl.html">WebGLのシェーダーとGLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>画像処理</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-image-processing.html">WebGLにおける画像処理</a></li>
<li><a href="/webgl/lessons/ja/webgl-image-processing-continued.html">WebGLにおける画像処理。続き</a></li>
        </ul>
  <li>2Dでの移動、回転、拡大縮小、行列計算</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-2d-translation.html">二次元での移動</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-rotation.html">二次元での回転</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-scale.html">二次元での拡大縮小</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-matrices.html">二次元での行列数学</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-orthographic.html">三次元の正投影</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-perspective.html">三次元透視投影</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-camera.html">三次元のカメラ</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-lighting-directional.html">三次元指向性光源</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-lighting-point.html">三次元点光源</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ja/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/ja/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ja/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ja/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-textures.html">テクスチャ</a></li>
<li><a href="/webgl/lessons/ja/webgl-data-textures.html">データテクスチャ</a></li>
<li><a href="/webgl/lessons/ja/webgl-2-textures.html">複数のテクスチャを使う</a></li>
<li><a href="/webgl/lessons/ja/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/ja/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/ja/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ja/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ja/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ja/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ja/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ja/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ja/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ja/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ja/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ja/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-setup-and-installation.html">WebGLの開発環境</a></li>
<li><a href="/webgl/lessons/ja/webgl-boilerplate.html">WebGLのひな型コード</a></li>
<li><a href="/webgl/lessons/ja/webgl-resizing-the-canvas.html">WebGLとcanvasのリサイズ</a></li>
<li><a href="/webgl/lessons/ja/webgl-animation.html">アニメーション</a></li>
<li><a href="/webgl/lessons/ja/webgl-points-lines-triangles.html">点、線、三角形</a></li>
<li><a href="/webgl/lessons/ja/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ja/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ja/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/ja/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/ja/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ja/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/ja/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ja/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ja/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ja/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ja/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ja/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs(英語)</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGLの仕組み';
            var disqus_title = 'WebGLの仕組み';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



