<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ja/webgl-3d-textures.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="WebGLのテクスチャの扱い方">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ja.jpg">

<meta property="og:title" content="WebGLのテクスチャ">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ja.jpg">
<meta property="og:description" content="WebGLのテクスチャの扱い方">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGLのテクスチャ">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html">
<meta name="twitter:description" content="WebGLのテクスチャの扱い方">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ja.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-3d-textures_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html",
      "inLanguage":"ja",
      "name":"WebGLのテクスチャ",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGLのテクスチャ</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-3d-textures.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-3d-textures.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-3d-textures.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-3d-textures.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-textures.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" selected>日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


    <a href="#toc">目次</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ja/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGLのテクスチャ</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>この記事はWebGLの連載シリーズのひとつである。
連載は「<a href="webgl-fundamentals.html">WebGLの基本</a>」から始まり、
前回は<a href="webgl-animation.html">アニメーション</a>について説明した。</p>
<p>WebGLでテクスチャを使用するにはどうすればよいだろう。
<a href="webgl-image-processing.html">WebGLにおける画像処理</a>を読めばその方法がわかるかもしれないが、
このページではもう少し詳しく解説をしよう。</p>
<p>まず最初に、シェーダーを調整する必要がある。
以下のコードは、頂点シェーダーの変更だ。
頂点シェーダーではフラグメントシェーダーへテクスチャ座標を渡す必要があるが、
特に何もせずストレートに受け渡しをすればよい。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">attribute vec4 a_position;
*attribute vec2 a_texcoord;

uniform mat4 u_matrix;

*varying vec2 v_texcoord;

void main() {
  // 座標データを行列で乗算する。
  gl_Position = u_matrix * a_position;

*  // テクスチャ座標をフラグメントシェーダーへ渡す。
*  v_texcoord = a_texcoord;
}
</code></pre><p>フラグメントシェーダーでは、<code class="notranslate" translate="no">sampler2D</code>というuniform変数を定義する。
これはテクスチャを参照する変数だ。
そして、頂点シェーダーから渡されたテクスチャ座標をもとに、
<code class="notranslate" translate="no">texture2D</code>を実行してテクスチャから色を抽出する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision mediump float;

// 頂点シェーダーから渡されたテクスチャ座標
*varying vec2 v_texcoord;

*// テクスチャー
*uniform sampler2D u_texture;

void main() {
*   gl_FragColor = texture2D(u_texture, v_texcoord);
}
</code></pre><p>次に、JavaScript側でテクスチャ座標を設定しよう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// テクスチャ座標の書き込み先となる、シェーダーのattributeのロケーションを得る。
var positionLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
*var texcoordLocation = gl.getAttribLocation(program, &quot;a_texcoord&quot;);

...

*// テクスチャ座標を格納するためのバッファーを作成する。
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
*gl.enableVertexAttribArray(texcoordLocation);
*
*// 32bit浮動小数点数(float)でシェーダーへ渡す。
*gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);
*
*// テクスチャ座標を設定する関数を実行する。
*setTexcoords(gl);
</code></pre><p>立体「F」を構成する各四角形それぞれにテクスチャすべてをマッピングしている関数が以下である。
※「F」は、16枚の四角形（四角形一つにつき二つの三角形ポリゴンで構成）で成り立っている。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*// 「F」に適用するテクスチャ座標をバッファーに格納する。
*function setTexcoords(gl) {
*  gl.bufferData(
*      gl.ARRAY_BUFFER,
*      new Float32Array([
*        // 左縦列
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
*
*        // 上の横棒
*        0, 0,
*        0, 1,
*        1, 0,
*        0, 1,
*        1, 1,
*        1, 0,
* ...
*       ]),
*       gl.STATIC_DRAW);
</code></pre><p>座標を設定できたら、次はテクスチャが必要だ。
一から作成することもできるが、今回は最も一般的な方法である
画像を読み込む方法で進めてみよう。</p>
<p>以下の画像が今回使用するテクスチャである。</p>
<p><img class="webgl_center" src="../../resources/f-texture.png" /></p>
<p>おいおい、めちゃくちゃイケてる画像じゃないか...！
実際「F」の画像というのは、方向がはっきりしている画像である。
そのため、
回転しているのか・反転しているのかなどを判別しやすく
テクスチャとして使用するのに適している。</p>
<p>ところで、ブラウザでは画像の読み込みは非同期で行われる。
画像の読み込みをリクエストして、
ブラウザがダウンロードを完了するまで多少時間がかかる。
この問題を解決する方法は二つある。
一つ目は、テクスチャがダウンロードを完了するまで待ち、その後描画を開始する方法。
二つ目は、仮のテクスチャを事前に作成しておく方法。
この方法であれば、画像のダウンロードを待たずすぐに描画を始めることができる。
画像がダウンロードされたら、仮で作成しておいたテクスチャにダウンロードした画像をコピーすればよい。
以下、後者の方法で進めよう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">*// テクスチャを作成する。
*var texture = gl.createTexture();
*gl.bindTexture(gl.TEXTURE_2D, texture);
*
*// 1x1の青色ピクセルで構成される仮のテクスチャを作成する。
*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
*              new Uint8Array([0, 0, 255, 255]));
*
*// 非同期で画像を読み込む。
*var image = new Image();
*image.src = &quot;resources/f-texture.png&quot;;
*image.addEventListener(&#39;load&#39;, function() {
*  // 画像が読み込めたら、仮のテクスチャに画像をコピーする。
*  gl.bindTexture(gl.TEXTURE_2D, texture);
*  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
*  gl.generateMipmap(gl.TEXTURE_2D);
*});
</code></pre><p>以上を踏まえると、下記のようになる。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>さて、上記の例は「F」を構成するそれぞれの四角形別々にテクスチャを貼っているが、
立体「F」の前面にちょうどテクスチャの「F」の部分を貼りたい時はどうすればよいか考えてみよう。
結論、<code class="notranslate" translate="no">setTexcoords</code>関数を変更すればよい。</p>
<p>まず最初に、テクスチャ座標の基本について理解しよう。
テクスチャは「テクスチャ座標」で参照され、
その座標の範囲は左から右へ0.0〜1.0、
最初の行の最初のピクセルから最後の行の最後のピクセルへ0.0から1.0である。
後者について、なぜ「上下」という表現を使わないのか？
それはテクスチャの座標系においては、「上下」は意味を持たないからである。
なぜなら、あなたが何かを描画してその方向づけを行うまでは、上下の概念が確定しないからだ。
とにかく、重要なのはWebGLにテクスチャのデータを渡すこと。
そのデータの開始点はテクスチャ座標の(0,0)、終了点は(1,1)である。</p>
<p><img class="webgl_center noinvertdark" width="405" src="../resources/texture-coordinates-diagram.svg" /></p>
<p>次に、photoshopにテクスチャを読み込ませて、座標をピクセル単位で調べてみよう。</p>
<p><img class="webgl_center" width="256" height="256" src="../../resources/f-texture-pixel-coords.png" /></p>
<p>ピクセル座標からテクスチャ座標へ変換するには、下記のようにすればよい。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">texcoordX = pixelCoordX / (width  - 1)
texcoordY = pixelCoordY / (height - 1)
</code></pre><p>「F」の前面全体に適用するテクスチャ座標は、以下のようになる。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 左縦列
 38 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255,  44 / 255,
 38 / 255, 223 / 255,
113 / 255, 223 / 255,
113 / 255,  44 / 255,

// 上の横棒
113 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 44 / 255,
113 / 255, 85 / 255,
218 / 255, 85 / 255,
218 / 255, 44 / 255,

// 真ん中の横棒
113 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 112 / 255,
113 / 255, 151 / 255,
203 / 255, 151 / 255,
203 / 255, 112 / 255,
</code></pre><p>上記に加えて「F」の裏側も同じようにテクスチャ座標を調整した結果、以下のようになる。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-coords-mapped.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-coords-mapped.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>あまり面白い見た目ではないかもしれないけど。。
これでテクスチャ座標の使い方がわかってもらえると嬉しい。
もし立方体や球体など簡単なジオメトリを作成する場合なら、
テクスチャ座標は簡単に計算することができる。
しかし、Blender・Maya・3D Studio Maxなどの3Dモデリングソフトでモデリングされた場合は、
テクスチャ座標はコード上ではなくそのソフト内で調整することになるだろう。</p>
<p>ところで、0.0から1.0の範囲を越えたテクスチャ座標を設定したらどうなるか考えてみよう。
WebGLのデフォルトは、繰り返し表示である。
0.0から1.0で、「1単位のテクスチャのコピー」と考えてみよう。
例えば、1.0から2.0の範囲でも1単位のコピーだ。
-4.0から-3.0の範囲でも1単位のコピーである。
これらの範囲を設定した板ポリゴン（平面）を描画してみよう。
0.0〜1.0の範囲外の座標を設定するため、
<code class="notranslate" translate="no">setTexcoords</code>を下記のように編集する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"> -3, -1,
  2, -1,
 -3,  4,
 -3,  4,
  2, -1,
  2,  4,
</code></pre><p>その結果が下記だ。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-repeat-clamp.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-repeat-clamp.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>WebGLのデフォルトは繰り返しだが、
<code class="notranslate" translate="no">CLAMP_TO_EDGE</code>を使用することで特定の方向へ繰り返しをさせないようにすることができる。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
</code></pre><p>上記のサンプルの中のボタンをクリックして、表示の違いを確認してほしい。</p>
<p>さて、ここで気づいた人もいるかもしれないが、
テクスチャを読み込む時に<code class="notranslate" translate="no">gl.generateMipmap</code>という関数を実行していることに注目してほしい。
これはどういう意味があるのだろうか？</p>
<p>下図のような16x16（ピクセル）のテクスチャがあったとする。</p>
<p><img class="webgl_center" src="../resources/mip-low-res-enlarged.png" style="border: 2px solid black;" /></p>
<p>例えば、2x2の大きさの板ポリゴン（平面）にこの16x16のテクスチャを描画したいとしよう。
このとき、この2x2=4pxをそれぞれ何色で塗ればよいだろうか？
当然、16x16=256通りから選ぶことになる。
例えばPhotoshopであれば、16x16の四隅の8x8の部分をそれぞれ平均化し、
2x2の画像にする。
しかし、この8x8=64pxをすべて読み取って平均化する上記の方法は、
GPUにとってはあまりに負荷が多い処理方法だ。
極端な例で考えてみよう。
2048x2048のサイズのテクスチャを持っていたとして、それを2x2サイズで描画する場合で考える。
Photoshopの例なら、2048x2048の四隅である1024x1024=100万px以上。。を平均化することになる。
これでは、高速に処理するには無理な方法である。</p>
<p>なので、GPUが採用する方法は「ミップマップ」というものである。
ミップマップとは、一番大きい元のサイズを基準にして、徐々に小さくなっていく画像の集まりである。
それぞれの画像は、前のイメージの大きさの1/4のサイズである。
例えば、上図の例であげた16x16のテクスチャのミップマップは以下のようになる。</p>
<p><img class="webgl_center noinvertdark nobg" src="../resources/mipmap-low-res-enlarged.png" /></p>
<p><code class="notranslate" translate="no">gl.generateMipmap</code>は行うことは、元となる大きな画像を参照し、
それをバイリニア補間をしてそれぞれの大きさのミップマップを作成することだ。
この関数を使わず、自ら小さい画像を用意しミップマップを揃えることも可能である。</p>
<p>16x16のテクスチャを2x2のサイズで描画するとき、
WebGLは前のミップから平均化された2x2のミップを選択することができる。</p>
<p>テクスチャのフィルタリングを設定して、WebGLが行う処理を選択することができる。
以下の6つのモードだ。</p>
<ul>
<li><code class="notranslate" translate="no">NEAREST</code> = 最大サイズのミップから、1ピクセルを選択する</li>
<li><code class="notranslate" translate="no">LINEAR</code> = 最大サイズのミップから4ピクセルを選択し、それらをブレンドする</li>
<li><code class="notranslate" translate="no">NEAREST_MIPMAP_NEAREST</code> = 最適なサイズのミップを選択し、その中の1ピクセルを選択する</li>
<li><code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code> = 最適なサイズのミップを選択し、その中の4ピクセルを選択しブレンドする</li>
<li><code class="notranslate" translate="no">NEAREST_MIPMAP_LINEAR</code> = 最適なサイズのミップを二つ選択し、それぞれから1ピクセルずつ選択しブレンドする</li>
<li><code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code> = 最適なサイズのミップを二つ選択し、それぞれから4ピクセルずつ選択しブレンドする</li>
</ul>
<p>これから二つの実装例を通して、ミップマップの重要性を学ぼう。
まず最初の例を見てみよう。
ここでは、最大サイズのミップしか使用しない<code class="notranslate" translate="no">NEAREST</code>または<code class="notranslate" translate="no">LINEAR</code>を採用する場合に多くの「ちらつき」が発生することがわかる。
サイズと位置がアニメーションで変更されるとき、
あるフレームではとある1pxを抽出し、また別のフレームではまた別の1pxを抽出するので、
大きなちらつきが発生する訳である。
下記の例で具体例を示す。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>それぞれの行について、
左と真ん中はちらつきが大きく、逆に右はちらつきが小さいことに注目しよう。
また、右側はミップ(最大サイズではない、バイリニア補間されたミップ)を使用しているため色が混ざっていることが確認できる。
一般的に、WebGLは描画するテクスチャが小さければ小さいほど、大元の大きなテクスチャから抽出するピクセル幅は大雑把になる。
例えば、一番下の真ん中のテクスチャは<code class="notranslate" translate="no">LINEAR</code>で4つのピクセルをブレンドしているにもかかわらず、ちらつきが大きくなっている。
この4つのピクセルは、16x16画像の四隅それぞれから1pxずつ抽出されているので、
それぞれの四隅のうちのどのピクセルを採用するかで色は大きく変化するはずである。
右下のテクスチャは<code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code>であり、一番小さいサイズ(1x1)から数えて二番目のミップ(2x2)を使用している。
そのため、ちらつきが少なくほぼ色の変化がない。</p>
<p>二つ目の例は、画面の奥にポリゴンが続いているような描画だ。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-mips-tri-linear.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-mips-tri-linear.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>画面の奥へ向かう6本の線は、それぞれ別々の6つのフィルタリングモードを適用している。
左上の線は<code class="notranslate" translate="no">NEAREST</code>を使用しているのだが、明らかにブロック状になっていることがわかるだろう。
中央（上）の線は <code class="notranslate" translate="no">LINEAR</code>を使用しているが、そこまで良い表示ではない。
右上は<code class="notranslate" translate="no">NEAREST_MIPMAP_NEAREST</code>を使用している。
ここで、ミップをどう使用しているかわかりやすく表示させるため、画面をクリックしてみてほしい。
奥行きに応じてミップが異なる色に変わり、どのサイズのミップが採用されているかわかりやすくなっただろう。この表示をもとに次の解説を読み進めてほしい。
左下は<code class="notranslate" translate="no">LINEAR_MIPMAP_NEAREST</code>であり、最適なミップを一つ選択し4ピクセルを抽出しブレンドする。
このとき、ミップとミップの間の境界線がはっきり見えてしまっていることがわかるだろう。
中央（下）の線は<code class="notranslate" translate="no">NEAREST_MIPMAP_LINEAR</code>であり、最適な2つのミップを選択し、それぞれから1ピクセルずつ選んでブレンドしている。
これでもまだ一部ブロック状になっていることが確認できる。
最後に右下は<code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code>で、最適な4つのミップを選択し、それぞれから4ピクセルずつ選んで8ピクセルすべてをブレンドしている。</p>
<p><img class="webgl_center noinvertdark nobg" src="../resources/different-colored-mips.png" /></p>
<div class="webgl_center">異なる大きさのミップそれぞれに異なる配色を施したミップマップ</div>

<p>上記の例の通り<code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code>が一番綺麗に描画されるのだが、
ではこのフィルタリング方法だけを使えば良いのではないか、という疑問が生まれるだろう。
ところがそうはいかない。三つ留意するべきポイントがある。</p>
<p>一つ目は、<code class="notranslate" translate="no">LINEAR_MIPMAP_LINEAR</code>は最も負荷が高い方法ということだ。
単純に、8ピクセルを読み込むことは1ピクセルを読み込むことより時間がかかる。
今時のGPUを前提としたときに、例えば一つのテクスチャを使用する場合だとさほど問題にはならないだろう。
しかし、今時のゲームは一度に2〜4枚ほどのテクスチャを使用することもある。
この場合、1ピクセルを描画するために、4テクスチャx8ピクセル=32ピクセルを読み込まなければならない。
当然処理は遅くなってしまうだろう。</p>
<p>二つ目のポイントは、特定の効果を生み出したい場合だ。
例えば、ゲームボーイのようなレトロなゲームの雰囲気を作りたいのであれば<code class="notranslate" translate="no">NEAREST</code>を使用してピクセルアートっぽく描画するとよいだろう。</p>
<p>三つ目のポイントとして、そもそもミップマップは多くのメモリーを消費する。
実際、未使用時と比べて33%も多くメモリーを消費するのである。
特に、ゲームのタイトル画面で使用されるような大きなサイズのテクスチャは、ミップマップを作成すると多くのメモリを必要とする。
もし、一番大きなミップより小さいものを描画する必要がないのであれば、そもそもミップマップを作成する必要はないだろう。
<code class="notranslate" translate="no">NEAREST</code>または<code class="notranslate" translate="no">LINEAR</code>を使用すればよいだけだ。</p>
<p>どのフィルタリングを採用するかは、<code class="notranslate" translate="no">gl.texParameter</code>を使用して下記のように記述すればよい。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
</code></pre><p><code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code>は、描画するサイズが最大のミップよりも小さい場合に記述する。
<code class="notranslate" translate="no">TEXTURE_MAG_FILTER</code>は、描画するサイズが最大のミップよりも大きい場合に記述する。
<code class="notranslate" translate="no">TEXTURE_MAG_FILTER</code>は、<code class="notranslate" translate="no">NEAREST</code>と<code class="notranslate" translate="no">LINEAR</code>のみ設定できる。</p>
<p>ここで、もうひとつ違うテクスチャ画像の例を見てみよう。</p>
<p><img class="webgl_center" src="../../resources/keyboard.jpg" /></p>
<p>これを適用すると、こうなる。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-bad-npot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-bad-npot.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>なぜキーボード画像のテクスチャが表示されないのだろう？
それは、テクスチャの縦・横のサイズそれぞれが2の累乗でない場合にWebGLが厳しい制約を設けているからである。
2の累乗とは、1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048などの数値のことだ。
今まで使用していた「F」のテクスチャは、256x256のサイズだった。256は2の累乗だ。
ところが、キーボードのテクスチャは320x240であり、縦も横も2の累乗ではないのでテクスチャ表示に失敗したという訳だ。
シェーダーで<code class="notranslate" translate="no">texture2D</code>が実行されるとき、参照するテクスチャが正しく設定されていないと、WebGLは黒色を表す(0,0,0,1)を表示する。
またブラウザによっては、JavaScriptのコンソールやWebのコンソールで下記のようなエラーが吐かれているかもしれない。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">WebGL: INVALID_OPERATION: generateMipmap: level 0 not power of 2
   or not all the same size
WebGL: drawArrays: texture bound to texture unit 0 is not renderable.
   It maybe non-power-of-2 and have incompatible texture filtering or
   is not &#39;texture complete&#39;.
</code></pre><p>この問題を解決するには、繰り返しの設定を<code class="notranslate" translate="no">CLAMP_TO_EDGE</code>に設定し、フィルタリングを<code class="notranslate" translate="no">LINEAR</code>または<code class="notranslate" translate="no">NEAREST</code>にしてミップマップを作成しない設定へ変更する必要がある。</p>
<p>2の累乗問題を修正するために、画像読み込みの記述を変更しよう。
まず、ある数値が2の累乗かどうかを判定する関数が必要だ。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">function isPowerOf2(value) {
  return (value &amp; (value - 1)) == 0;
}
</code></pre><p>なぜこれで2の累乗か判定できるのかは、一旦置いておこう。
そして、以下のように使用する。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// 非同期で画像を読み込む。
var image = new Image();
image.src = &quot;resources/keyboard.jpg&quot;;
image.addEventListener(&#39;load&#39;, function() {
  // 画像が読み込めたら、仮のテクスチャに画像をコピーする。
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);

*  // 縦・横それぞれについて、2の累乗の数値かどうか判定する。
*  if (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
*     // 2の累乗であれば、ミップマップを作成する。
     gl.generateMipmap(gl.TEXTURE_2D);
*  } else {
*     // 2の累乗であれば、ミップマップを作成しない。繰り返しをCLAMP_TO_EDGEに設定する
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
*     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
*  }
}
</code></pre><p>上記を設定すると、次のようになる。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-good-npot.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-good-npot.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>ところで、レンダリングできないのは「2の累乗ではないテクスチャ」だけではない。
WebGLは「テクスチャ・コンプリート」であることを求めている。
「テクスチャ・コンプリート」とは、下記のいずれかの条件を満たしていることである。</p>
<ol>
<li><p><code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code>を<code class="notranslate" translate="no">LINEAR</code>または<code class="notranslate" translate="no">NEAREST</code>に設定することで、一番大きいミップのみを使用するようにフィルタリングを設定すること。</p>
</li>
<li><p>ミップマップを使用する場合は正しいサイズで、1x1まで用意すること。</p>
<p>上記を達成する一番簡単な方法は、<code class="notranslate" translate="no">gl.generateMipmap</code>を実行すること。または自分ですべてのミップマップを用意すること。</p>
</li>
<li><p>テクスチャの縦・横のサイズが2の累乗でない場合は、<code class="notranslate" translate="no">TEXTURE_MIN_FILTER</code>を<code class="notranslate" translate="no">LINEAR</code>または<code class="notranslate" translate="no">NEAREST</code>に設定し、
<strong>かつ</strong><code class="notranslate" translate="no">CLAMP_TO_EDGE</code>を<code class="notranslate" translate="no">TEXTURE_WRAP_S</code>または<code class="notranslate" translate="no">TEXTURE_WRAP_T</code>に設定すること。</p>
</li>
</ol>
<p>上記の三つの条件をいずれも満たさない場合は、シェーダーでテクスチャの値を取得しようとすると(0,0,0,1)が返されてしまう。</p>
<p>最後に、よくある質問である「立方体の各面に異なるテクスチャを適用するにはどうしたらいいだろう？」という疑問について考えてみよう。</p>
<div class="webgl_table_div_center">
<table class="webgl_table_center">
<tr><td><img src="../resources/noodles-01.jpg" /></td><td><img src="../resources/noodles-02.jpg" /></td></tr>
<tr><td><img src="../resources/noodles-03.jpg" /></td><td><img src="../resources/noodles-04.jpg" /></td></tr>
<tr><td><img src="../resources/noodles-05.jpg" /></td><td><img src="../resources/noodles-06.jpg" /></td></tr>
</table>
</div>

<p>方法として、三つの回答が思い浮かぶ。それぞれ見てみよう。</p>
<p>1) 6つのテクスチャを参照する複雑なシェーダーを作成し、頂点ごとの追加情報を頂点シェーダーに渡し、さらにそれがフラグメントシェーダーに渡されて、使用されるテクスチャが決定されるようにする。これはマジでダメな方法だ。少し考えればわかることだが、この方法だと複雑な形状の図形で、面の数が増えれば増えるほどシェーダーは複雑になってしまう。</p>
<p>2) 立方体ではなく、6つの平面を描画する。これは一般的な解決策だろう。これは悪い方法ではないが、立方体など単純な図形にしか使えない方法だ。もし、1000の板ポリゴンで描画される球体があったとして、それぞれに異なるテクスチャを適用したいとしよう。この場合1000個の板ポリゴンを描画する必要があり、これは処理が重いだろう。</p>
<p>3) すべてのテクスチャを一枚の画像に収める。テクスチャ座標を使って、立方体の各面それぞれにテクスチャの一部分をマッピングする。おそらくこれが一番の解決策だろう。これは、すべての高性能アプリ（ゲームも含む）が利用している解決法だ。</p>
<p>三つ目の方法を採用する場合、画像は下記のようになる。</p>
<p><img class="webgl_center" src="../../resources/noodles.jpg" /></p>
<p>そして、立方体の各面について異なるテクスチャ座標を設定しよう。</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">    // 左上の画像
    0   , 0  ,
    0   , 0.5,
    0.25, 0  ,
    0   , 0.5,
    0.25, 0.5,
    0.25, 0  ,
    // 上の真ん中の画像
    0.25, 0  ,
    0.5 , 0  ,
    0.25, 0.5,
    0.25, 0.5,
    0.5 , 0  ,
    0.5 , 0.5,
    // 右上の画像
    0.5 , 0  ,
    0.5 , 0.5,
    0.75, 0  ,
    0.5 , 0.5,
    0.75, 0.5,
    0.75, 0  ,
    // 左下の画像
    0   , 0.5,
    0.25, 0.5,
    0   , 1  ,
    0   , 1  ,
    0.25, 0.5,
    0.25, 1  ,
    // 下の真ん中の画像
    0.25, 0.5,
    0.25, 1  ,
    0.5 , 0.5,
    0.25, 1  ,
    0.5 , 1  ,
    0.5 , 0.5,
    // 右下の画像
    0.5 , 0.5,
    0.75, 0.5,
    0.5 , 1  ,
    0.5 , 1  ,
    0.75, 0.5,
    0.75, 1  ,
</code></pre><p>下が結果である。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-textures-texture-atlas.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-textures-texture-atlas.html" target="_blank">クリックして別のウインドウを開く</a>
</div>

</p>
<p>このように、一枚のテクスチャで複数の画像を適用する方法を、「テクスチャアトラス」と呼ぶ。
ロードするテクスチャが一枚なので、シェーダーはひとつのテクスチャを参照するだけでよくなる。
また、先述の二つ目の方法で言及した板ポリゴン（平面）でそれぞれ描画する方法と比べて、
描画回数が1回で良いことから、これは最適な方法といえるだろう。</p>
<p>他にも、テクスチャについて学ぶべきことはいくつかある。
ひとつは、<a href="webgl-texture-units.html">テクスチャユニットが、どのように機能するか</a>というテーマだ。
もうひとつは、<a href="webgl-2-textures.html">一度に二つ以上のテクスチャを適用する方法</a>だ。
<a href="webgl-cors-permission.html">他ドメインの画像を使用する方法</a>についても目を通しておきたい。
そこまで学習できたら、<a href="webgl-3d-perspective-correct-texturemapping.html">透視投影での正しいテクスチャマッピング</a>を見ると良い。
トリビア級の知識だが、知っておいて損はないだろう。</p>
<p>次は、<a href="webgl-data-textures.html">WebGLのデータテクスチャ</a>の話をしよう。
<a href="webgl-less-code-more-fun.html">少ないコードでより楽しくWebGLを簡素化する</a>もチェックしてほしい。</p>
<div class="webgl_bottombar">
<h3>UVとテクスチャ座標</h3>
<p>Texture coordinates（テクスチャ座標）は、よく"texture coords"とか"texcoords"、または単純に"UVs"と省略されたりする。
("Ew-Vees"と発音する)。 UVsという用語の由来ははっきりとはわからない。
ただ、頂点座標は<code class="notranslate" translate="no">x, y, z, w</code>が使われるから、代わりにテクスチャ座標は<code class="notranslate" translate="no">s, t, u, v</code>
を使うことになったのだと思う。ところで、(s,t)と(u,v)のうちどっちの組み合わせを使うべきなのだろう。
実際、テクスチャの折り返し設定では<code class="notranslate" translate="no">TEXTURE_WRAP_S</code>と<code class="notranslate" translate="no">TEXTURE_WRAP_T</code>という名前になっているから、
"Es-Tees"と呼んで良さそうだけど、私の仕事の経験上、なぜかみんな"Ew-Vees"と呼んでいた。
</p>
<p>ともかく、誰かが"UVs"と言ったらそれはテクスチャ座標のことを表している。</p>
</div>




    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-3d-textures.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-3d-textures.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-3d-textures.html" selected>日本語</a>
    <option value="/webgl/lessons/ko/webgl-3d-textures.html" >한국어</a>
    <option value="/webgl/lessons/pl/webgl-3d-textures.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-3d-textures.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-3d-textures.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-3d-textures.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-fundamentals.html">基本</a></li>
<li><a href="/webgl/lessons/ja/webgl-how-it-works.html">WebGLの仕組み</a></li>
<li><a href="/webgl/lessons/ja/webgl-shaders-and-glsl.html">WebGLのシェーダーとGLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL State Diagram</a></li>
        </ul>
  <li>画像処理</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-image-processing.html">WebGLにおける画像処理</a></li>
<li><a href="/webgl/lessons/ja/webgl-image-processing-continued.html">WebGLにおける画像処理。続き</a></li>
        </ul>
  <li>2Dでの移動、回転、拡大縮小、行列計算</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-2d-translation.html">二次元での移動</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-rotation.html">二次元での回転</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-scale.html">二次元での拡大縮小</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-matrices.html">二次元での行列数学</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-orthographic.html">三次元の正投影</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-perspective.html">三次元透視投影</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-camera.html">三次元のカメラ</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-lighting-directional.html">三次元指向性光源</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-lighting-point.html">三次元点光源</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ja/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/ja/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ja/webgl-load-obj.html">Loading .obj files</a></li>
<li><a href="/webgl/lessons/ja/webgl-load-obj-w-mtl.html">Loading .obj w .mtl files</a></li>
        </ul>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-3d-textures.html">テクスチャ</a></li>
<li><a href="/webgl/lessons/ja/webgl-data-textures.html">データテクスチャ</a></li>
<li><a href="/webgl/lessons/ja/webgl-2-textures.html">複数のテクスチャを使う</a></li>
<li><a href="/webgl/lessons/ja/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ja/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/ja/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
<li><a href="/webgl/lessons/ja/webgl-sprites.html">Sprites</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/ja/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/ja/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/ja/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ja/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ja/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/ja/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
  <li>テクスチャ</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ja/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ja/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ja/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ja/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>その他のトピック</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-setup-and-installation.html">WebGLの開発環境</a></li>
<li><a href="/webgl/lessons/ja/webgl-boilerplate.html">WebGLのひな型コード</a></li>
<li><a href="/webgl/lessons/ja/webgl-resizing-the-canvas.html">WebGLとcanvasのリサイズ</a></li>
<li><a href="/webgl/lessons/ja/webgl-animation.html">アニメーション</a></li>
<li><a href="/webgl/lessons/ja/webgl-points-lines-triangles.html">点、線、三角形</a></li>
<li><a href="/webgl/lessons/ja/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ja/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ja/webgl-and-alpha.html">WebGL and Alpha</a></li>
<li><a href="/webgl/lessons/ja/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/ja/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/ja/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
<li><a href="/webgl/lessons/ja/webgl-precision-issues.html">Precision Issues</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/webgl/lessons/ja/webgl-tips.html#html-background">Use WebGL as Background in HTML</a></li>
<li><a href="/webgl/lessons/ja/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ja/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/ja/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/ja/webgl-texture-units.html">Texture Units</a></li>
<li><a href="/webgl/lessons/ja/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ja/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ja/webgl-references.html">References</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs(英語)</a></li>
  <li><a href="https://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>問題点/バグ? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">githubでissueを作成</a>.</div>

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGLのテクスチャ';
            var disqus_title = 'WebGLのテクスチャ';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



